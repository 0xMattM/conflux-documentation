"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[1823],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),l=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=l(e.components);return n.createElement(d.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,d=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=l(a),m=r,h=p["".concat(d,".").concat(m)]||p[m]||u[m]||s;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=m;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},81997:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var n=a(87462),r=(a(67294),a(3905));const s={sidebar_position:1,title:"Base32 Addresses",displayed_sidebar:"coreSidebar"},o=void 0,i={unversionedId:"core/core-space-basics/addresses",id:"core/core-space-basics/addresses",title:"Base32 Addresses",description:"In Conflux, every account is associated with a pair of public and private keys, and is identified by an address. This page is about how address is presented and computed in core space.",source:"@site/docs/core/core-space-basics/addresses.md",sourceDirName:"core/core-space-basics",slug:"/core/core-space-basics/addresses",permalink:"/docs/core/core-space-basics/addresses",draft:!1,editUrl:"https://github.com/Conflux-Chain/conflux-documentation/edit/main/docs/core/core-space-basics/addresses.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Base32 Addresses",displayed_sidebar:"coreSidebar"},sidebar:"coreSidebar",previous:{title:"Intro",permalink:"/docs/core/core-space-basics/Intro"},next:{title:"Storage Collateral",permalink:"/docs/core/core-space-basics/storage"}},d={},l=[{value:"Hex and Base32 Addresses",id:"hex-and-base32-addresses",level:2},{value:"Address Computation",id:"address-computation",level:2},{value:"Hex Address Computation",id:"hex-address-computation",level:3},{value:"EOA Hex Address Computation",id:"eoa-hex-address-computation",level:4},{value:"Contract Address Computation",id:"contract-address-computation",level:4},{value:"Base32 Address Computation",id:"base32-address-computation",level:3},{value:"Network Prefix",id:"network-prefix",level:4},{value:"Address Type",id:"address-type",level:4},{value:"Payload",id:"payload",level:4},{value:"Checksum",id:"checksum",level:4},{value:"Final Result and Example",id:"final-result-and-example",level:4},{value:"Use Cases for Base32 and Hex Addresses",id:"use-cases-for-base32-and-hex-addresses",level:2},{value:"Address Format Convert Tool",id:"address-format-convert-tool",level:2}],c={toc:l},p="wrapper";function u(e){let{components:t,...s}=e;return(0,r.kt)(p,(0,n.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In Conflux, every ",(0,r.kt)("a",{parentName:"p",href:"/docs/general/conflux-basics/accounts"},"account")," is associated with a pair of public and private keys, and is identified by an address. This page is about how address is presented and computed in core space. "),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Refer to ",(0,r.kt)("a",{parentName:"p",href:"/docs/general/conflux-basics/accounts#address"},"General-address")," for the basic concepts about addresses. ")),(0,r.kt)("h2",{id:"hex-and-base32-addresses"},"Hex and Base32 Addresses"),(0,r.kt)("p",null,"Before the release of ",(0,r.kt)("inlineCode",{parentName:"p"},"Conflux-rust v1.1.1"),", Conflux addresses were exclusively presented as hex-encoded strings, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"0x1292d4955bb47f5153b88ca12c7a9e4048f09839"),". This format closely resembles addresses used by Ethereum and other EVM-compatible blockchains. However, Conflux employs a unique method to compute EOA addresses, which means that the address strings generated from the same private key will usually differ between Conflux and Ethereum. This similarity in appearance, combined with the difference in computation, makes it all too easy for users to confuse Conflux addresses with Ethereum addresses, potentially leading to the loss of assets."),(0,r.kt)("p",null,"In order to address this issue, Conflux introduced a new base32-encoded address format in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Conflux-Chain/CIPs/blob/master/CIPs/cip-37.md"},"CIP-37"),'. The new format is derived directly from the original hex-encoded addresses including a distinctive prefix (such as "cfx"), an optional address type, and a checksum. As a result, the hex-encoded address mentioned earlier can be converted into a more easily recognizable base32 address, like ',(0,r.kt)("inlineCode",{parentName:"p"},"cfx:aakkfzezns4h8ymx1cgmcnd4x3aev6e2hexz250ym5"),", or an alternative verbose format with an optional address type, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"CFX:TYPE.USER:AAKKFZEZNS4H8YMX1CGMCND4X3AEV6E2HEXZ250YM5"),". This new format minimizes the risk of confusion between Conflux and Ethereum addresses, offering a safer and more user-friendly experience."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Base32 addresses are utilized throughout the Conflux core ecosystem, with the exception of smart contract ",(0,r.kt)("inlineCode",{parentName:"p"},".sol")," source code. In cases where a hardcoded ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-55"},"EIP-55")," checksum address is necessary within ",(0,r.kt)("inlineCode",{parentName:"p"},".sol")," files, developers should opt for a Conflux hex-encoded address instead of the base32 format.")),(0,r.kt)("h2",{id:"address-computation"},"Address Computation"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This section is informational in nature. Typically, users or developers won't need to calculate the hex address on their own. It's advised to rely on the return values from the SDK or RPC to obtain the EOA/contract address, and to use the SDK or ",(0,r.kt)("a",{parentName:"p",href:"https://www.confluxscan.net/address-converter"},"online address converter")," for converting between hex and base32 address formats.")),(0,r.kt)("h3",{id:"hex-address-computation"},"Hex Address Computation"),(0,r.kt)("p",null,"Base32 addresses are derived directly from the original hex-encoded addresses. Therefore, we need to understand the computation of hex addresses."),(0,r.kt)("p",null,'A Conflux hex address is a 20-byte hex value, represented as a 42-character string starting with "0x". The hex-encoded address starts with a 1(3)-character "type indicator" that signifies the address type. There are currently three types of indicators:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(0x)1"),": Represents the address of an EOA account."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(0x)8"),": Represents the address of a contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(0x)0"),": Represents the address of an ",(0,r.kt)("a",{parentName:"li",href:"/docs/core/core-space-basics/internal-contracts/"},"internal contract"),", which implements hard-coded logic on the chain, or a null address (",(0,r.kt)("inlineCode",{parentName:"li"},"0x0000000000000000000000000000000000000000"),").")),(0,r.kt)("h4",{id:"eoa-hex-address-computation"},"EOA Hex Address Computation"),(0,r.kt)("p",null,"The computaion of EOA hex address is specified in ",(0,r.kt)("a",{parentName:"p",href:"https://www.confluxnetwork.org/files/Conflux_Protocol_Specification.pdf"},"Conflux protocol specification")," ",(0,r.kt)("inlineCode",{parentName:"p"},"3.1: Accounts"),". The account address is a concatenation of a 4-bit type indicator and the rightmost 156-bit Keccak digest of the associated public key of the private key."),(0,r.kt)("h4",{id:"contract-address-computation"},"Contract Address Computation"),(0,r.kt)("p",null,"An contract can be deployed via ",(0,r.kt)("inlineCode",{parentName:"p"},"create2")," opcode or not."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The contract address computation is quite different from that of Ethereum. ")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"create2")," is used, the deployed address of can be computed as the following Python code described:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# using web3.py is also viable\n# from web3 import Web3\nfrom conflux_web3 import Web3\n\n# ensure salt is a bytes32 to avoid unmatched result caused by encoding approach\ndef compute_address_using_salt(salt: bytes, bytecode_hash: bytes, hex_deployer_address: str):\n    core_part = Web3.solidityKeccak(\n        ["bytes1", "address", "bytes32", "bytes32"],\n        ["0xff", hex_deployer_address, salt, bytecode_hash]\n    )\n    return "0x8"+ core_part.hex()[-39:]\n')),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"create2")," is not used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# using web3.py is also viable\n# from web3 import Web3\nfrom conflux_web3 import Web3\n\ndef compute_address_using_nonce(nonce: int, bytecode_hash: bytes, hex_deployer_address: str):\n    core_part = Web3.solidityKeccak(\n        ["bytes1", "address", "bytes32", "bytes32"],\n        ["0x00", hex_deployer_address, nonce.to_bytes(32, "little"), bytecode_hash]\n    )\n    return "0x8"+ core_part.hex()[-39:]\n')),(0,r.kt)("h3",{id:"base32-address-computation"},"Base32 Address Computation"),(0,r.kt)("p",null,"Conflux base32 address is a network-prefixed Conflux base32-checksum address defined in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Conflux-Chain/CIPs/blob/master/CIPs/cip-37.md"},"CIP-37"),". The address consists of a network-prefix indicating the network on which this address is valid, a colon (",(0,r.kt)("inlineCode",{parentName:"p"},'":"'),"), and a base32-encoded payload indicating the destination of the address and containing a checksum, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"cfx:aarc9abycue0hhzgyrr53m6cxedgccrmmyybjgh4xg"),". Optionally, the address can contain a list of key value pairs in the format ",(0,r.kt)("inlineCode",{parentName:"p"},"key.value")," between the network-prefix and the payload, separated by colons, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"cfx:type.user:aarc9abycue0hhzgyrr53m6cxedgccrmmyybjgh4xg"),". "),(0,r.kt)("h4",{id:"network-prefix"},"Network Prefix"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"network-prefix")," is one of the following values: ",(0,r.kt)("inlineCode",{parentName:"p"},'"cfx"')," (mainnet, corresponds to network-id 1029), ",(0,r.kt)("inlineCode",{parentName:"p"},'"cfxtest"')," (testnet, corresponds to network-id 1), ",(0,r.kt)("inlineCode",{parentName:"p"},'"net[n]"')," where ",(0,r.kt)("inlineCode",{parentName:"p"},"n != 1, 1029")," (private Conflux network)"),(0,r.kt)("p",null,"Examples of valid network-prefixes: ",(0,r.kt)("inlineCode",{parentName:"p"},'"cfx"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"cfxtest"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"net17"')),(0,r.kt)("p",null,"Examples of invalid network-prefixes: ",(0,r.kt)("inlineCode",{parentName:"p"},'"bch"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"conflux"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"net1"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"net1029"')),(0,r.kt)("h4",{id:"address-type"},"Address Type"),(0,r.kt)("p",null,"Address type is an optional field to provide human-readable information for the address type. For the null address (",(0,r.kt)("inlineCode",{parentName:"p"},"0x0000000000000000000000000000000000000000"),"), address-type must be ",(0,r.kt)("inlineCode",{parentName:"p"},"type.null"),". Otherwise,"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0x0"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"type.builtin")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0x1"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"type.user")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0x8"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"type.contract"))),(0,r.kt)("h4",{id:"payload"},"Payload"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Concatenate ",(0,r.kt)("inlineCode",{parentName:"li"},"version-byte"),": concatenate the ",(0,r.kt)("inlineCode",{parentName:"li"},"version-byte"),"(",(0,r.kt)("inlineCode",{parentName:"li"},"0x00"),") with hex address to get a 21-byte array."),(0,r.kt)("li",{parentName:"ol"},"Base32 encode: encode the above result left-to-right, mapping each 5-bit sequence to the corresponding ASCII character (see alphabet below). Pad to the right with zero bits(should be 2 bit 0-padding) to complete any unfinished chunk at the end.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"0x00 => a    0x08 => j    0x10 => u    0x18 => 2\n0x01 => b    0x09 => k    0x11 => v    0x19 => 3\n0x02 => c    0x0a => m    0x12 => w    0x1a => 4\n0x03 => d    0x0b => n    0x13 => x    0x1b => 5\n0x04 => e    0x0c => p    0x14 => y    0x1c => 6\n0x05 => f    0x0d => r    0x15 => z    0x1d => 7\n0x06 => g    0x0e => s    0x16 => 0    0x1e => 8\n0x07 => h    0x0f => t    0x17 => 1    0x1f => 9\n")))),(0,r.kt)("h4",{id:"checksum"},"Checksum"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Prepare checksum input: ",(0,r.kt)("inlineCode",{parentName:"li"},"data")," is used as the input of checksum function. It contains:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The lower 5 bits of each character of the ",(0,r.kt)("inlineCode",{parentName:"li"},"network-prefix"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},'"cfx..."')," becomes ",(0,r.kt)("inlineCode",{parentName:"li"},"0x03, 0x06, 0x18, ...")),(0,r.kt)("li",{parentName:"ul"},"A zero for the separator (5 zero bits)."),(0,r.kt)("li",{parentName:"ul"},"The payload by chunks of 5 bits. If necessary, the payload is padded to the right with zero bits to complete any unfinished chunk at the end."),(0,r.kt)("li",{parentName:"ul"},'Eight zeros as a "template" for the checksum.'))),(0,r.kt)("li",{parentName:"ol"},"Calculate checksum: calculate using ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md#checksum"},"Bitcoin Cash checksum algorithm")," over the ",(0,r.kt)("inlineCode",{parentName:"li"},"data"),"."),(0,r.kt)("li",{parentName:"ol"},"Base32 encode: encode the returned 40-bit checksum according to the same step in ",(0,r.kt)("a",{parentName:"li",href:"#payload"},"Payload-Base32 encode"))),(0,r.kt)("h4",{id:"final-result-and-example"},"Final Result and Example"),(0,r.kt)("p",null,"Concatenate the following parts to get the final address: ",(0,r.kt)("inlineCode",{parentName:"p"},"[network-prefix]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'":"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[payload]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[checksum]")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Optionally, ",(0,r.kt)("strong",{parentName:"li"},"address-type")," can also be included: ",(0,r.kt)("inlineCode",{parentName:"li"},"[network-prefix]"),", ",(0,r.kt)("inlineCode",{parentName:"li"},'":"'),", ",(0,r.kt)("inlineCode",{parentName:"li"},"[address-type]"),", ",(0,r.kt)("inlineCode",{parentName:"li"},'":"'),", ",(0,r.kt)("inlineCode",{parentName:"li"},"[payload]"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"[checksum]"))),(0,r.kt)("p",null,"Here is an example presenting each step of encoding:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'encode(0x1a2f80341409639ea6a35bbcab8299066109aa55, "cfx")\n\n1. address-type: "type.user"\n2. version-byte: 0x00\n3. payload: [0x00, 0x1a, 0x2f, 0x80, 0x34, 0x14, 0x09, 0x63, 0x9e, 0xa6, 0xa3, 0x5b, 0xbc, 0xab, 0x82, 0x99, 0x06, 0x61, 0x09, 0xaa, 0x55]\n   5-bit parts: [0x00, 0x00, 0x0d, 0x02, 0x1f, 0x00, 0x01, 0x14, 0x02, 0x10, 0x04, 0x16, 0x07, 0x07, 0x15, 0x06, 0x14, 0x0d, 0x0d, 0x1b, 0x19, 0x0a, 0x1c, 0x02, 0x13, 0x04, 0x03, 0x06, 0x02, 0x02, 0x0d, 0x0a, 0x0a, 0x14]\n   base32-encoded: "aarc9abycue0hhzgyrr53m6cxedgccrmmy"\n4. checksum input: [0x03, 0x06, 0x18, 0x00, 0x00, 0x00, 0x0d, 0x02, 0x1f, 0x00, 0x01, 0x14, 0x02, 0x10, 0x04, 0x16, 0x07, 0x07, 0x15, 0x06, 0x14, 0x0d, 0x0d, 0x1b, 0x19, 0x0a, 0x1c, 0x02, 0x13, 0x04, 0x03, 0x06, 0x02, 0x02, 0x0d, 0x0a, 0x0a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n   checksum output: 688543492710\n   checksum string: "ybjgh4xg"\n5. concatenated result: "cfx:type.user:aarc9abycue0hhzgyrr53m6cxedgccrmmyybjgh4xg"\n')),(0,r.kt)("h2",{id:"use-cases-for-base32-and-hex-addresses"},"Use Cases for Base32 and Hex Addresses"),(0,r.kt)("p",null,"The Conflux Core RPC methods only accept base32 address, so Conflux Core SDKs and wallets also use base32 address. Base32 is the most common address format in the Core Space."),(0,r.kt)("p",null,"For Conflux Core Space contract development, Ethereum toolchains are used to compile contracts. So in Solidity smart contract ",(0,r.kt)("inlineCode",{parentName:"p"},".sol")," files, base32 format addresses would bring about compilation errors. If a specific address needs to be hardcoded in the contract code, it should be in hex format. This is the only situation that hex address is used in the Core Space."),(0,r.kt)("h2",{id:"address-format-convert-tool"},"Address Format Convert Tool"),(0,r.kt)("p",null,"ConfluxScan provide a ",(0,r.kt)("a",{parentName:"p",href:"https://www.confluxscan.io/address-converter"},"Online Address Converter")," which is very useful."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(90781).Z,width:"1390",height:"815"})))}u.isMDXComponent=!0},90781:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/scan-address-converter-e7b61efba9861d32121a6e3aba72f821.png"}}]);