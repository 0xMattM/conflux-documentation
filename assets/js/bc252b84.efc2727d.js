"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[1598],{61892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var a=n(85893),r=n(11151);const s={displayed_sidebar:"generalSidebar"},c="Introduction to Transaction Traces",o={id:"general/build/node-development/trace-introduction",title:"Introduction to Transaction Traces",description:"Traces are used to record the transaction execution details. It can be used to debug or retrieve more information (like getting contract addresses created within transaction execution).",source:"@site/docs/general/build/node-development/trace-introduction.md",sourceDirName:"general/build/node-development",slug:"/general/build/node-development/trace-introduction",permalink:"/docs/general/build/node-development/trace-introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/Conflux-Chain/conflux-documentation/edit/main/docs/general/build/node-development/trace-introduction.md",tags:[],version:"current",frontMatter:{displayed_sidebar:"generalSidebar"},sidebar:"generalSidebar",previous:{title:"Test Framework",permalink:"/docs/general/build/node-development/test-framework"},next:{title:"Tools",permalink:"/docs/category/tools"}},i={},d=[{value:"Trace Types",id:"trace-types",level:2},{value:"Call",id:"call",level:3},{value:"CallResult",id:"callresult",level:3},{value:"Create",id:"create",level:3},{value:"CreateResult",id:"createresult",level:3},{value:"InternalTransferAction",id:"internaltransferaction",level:3},{value:"Discussion of Failure",id:"discussion-of-failure",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"introduction-to-transaction-traces",children:"Introduction to Transaction Traces"}),"\n",(0,a.jsx)(t.p,{children:"Traces are used to record the transaction execution details. It can be used to debug or retrieve more information (like getting contract addresses created within transaction execution)."}),"\n",(0,a.jsx)(t.h2,{id:"trace-types",children:"Trace Types"}),"\n",(0,a.jsx)(t.h3,{id:"call",children:"Call"}),"\n",(0,a.jsxs)(t.p,{children:["The trace is recorded for all ",(0,a.jsx)(t.code,{children:"Call"})," operations, including balance transferring or contract calling, executed either by the transaction itself or inside a contract."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Call {\n    /// The sending account.\n    pub from: Address,\n    /// The destination account.\n    pub to: Address,\n    /// The value transferred to the destination account.\n    pub value: U256,\n    /// The gas available for executing the call.\n    pub gas: U256,\n    /// The input data provided to the call.\n    pub input: Bytes,\n    /// The type of the call.\n    pub call_type: CallType,\n}\n\npub enum CallType {\n    /// Not a CALL.\n    None,\n    /// CALL.\n    Call,\n    /// CALLCODE.\n    CallCode,\n    /// DELEGATECALL.\n    DelegateCall,\n    /// STATICCALL\n    StaticCall,\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If a transaction itself is calling a contract (",(0,a.jsx)(t.code,{children:"to"})," is a contract address), this trace will always be the first one in the trace list of this transaction."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"call_type"})," can never be ",(0,a.jsx)(t.code,{children:"None"})," for ",(0,a.jsx)(t.code,{children:"Call"})," traces."]}),"\n",(0,a.jsxs)(t.p,{children:["Note that ",(0,a.jsx)(t.code,{children:"gas"}),' is the "provided" gas for the execution of the callee, so the gas overhead has been deducted. For example, it is ',(0,a.jsx)(t.code,{children:"0"})," for a simple balance transferring transaction of ",(0,a.jsx)(t.code,{children:"21000"})," gas, because the base gas cost (",(0,a.jsx)(t.code,{children:"21000"}),") has been deducted in advance. The gas cost for call-related opcodes (",(0,a.jsx)(t.code,{children:"CALL"}),", ",(0,a.jsx)(t.code,{children:"DELEGATECALL"}),", e.t.c.) or the 1/64 gas reserve for calling are also deducted in advance during contract execution."]}),"\n",(0,a.jsx)(t.h3,{id:"callresult",children:"CallResult"}),"\n",(0,a.jsxs)(t.p,{children:["The trace is recorded after a ",(0,a.jsx)(t.code,{children:"Call"})," operation finishes."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct CallResult {\n    /// The outcome of the result\n    pub outcome: Outcome,\n    /// The amount of gas left\n    pub gas_left: U256,\n    /// Output data\n    pub return_data: Bytes,\n}\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub enum Outcome {\n    Success,\n    Reverted,\n    Fail,\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"create",children:"Create"}),"\n",(0,a.jsxs)(t.p,{children:["The trace is recorded for all operations that create contracts, including executing contract creation transactions or successfully executing the ",(0,a.jsx)(t.code,{children:"CREATE"}),"/",(0,a.jsx)(t.code,{children:"CREATE2"})," opcode."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Create {\n    /// The address of the creator.\n    pub from: Address,\n    /// The value with which the new account is endowed.\n    pub value: U256,\n    /// The gas available for the creation init code.\n    pub gas: U256,\n    /// The init code.\n    pub init: Bytes,\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Similar to ",(0,a.jsx)(t.code,{children:"Call"}),", the ",(0,a.jsx)(t.code,{children:"gas"}),' is the "provided" gas for the ',(0,a.jsx)(t.code,{children:"Create"})," operation."]}),"\n",(0,a.jsx)(t.h3,{id:"createresult",children:"CreateResult"}),"\n",(0,a.jsxs)(t.p,{children:["The trace is recorded after a ",(0,a.jsx)(t.code,{children:"Create"})," operation finishes."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct CreateResult {\n    /// The outcome of the create\n    pub outcome: Outcome,\n    /// The created contract address\n    pub addr: Address,\n    /// The amount of gas left\n    pub gas_left: U256,\n    /// Output data\n    pub return_data: Bytes,\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"addr"})," can only be used if ",(0,a.jsx)(t.code,{children:"outcome"})," is ",(0,a.jsx)(t.code,{children:"Success"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"internaltransferaction",children:"InternalTransferAction"}),"\n",(0,a.jsx)(t.p,{children:"The trace is recorded for the balance transfer triggered by internal contracts. It includes contract suicide, sponsor replacement (including storage collateral sponsor and gas sponsor) , and staking."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct InternalTransferAction {\n    /// The source address. If it is zero, then it is an interest mint action.\n    pub from: Address,\n    /// The destination address. If it is zero, then it is a burnt action.\n    pub to: Address,\n    /// The amount of CFX\n    pub value: U256,\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For contract suicide, if the refund address is the to-be-destroyed contract , the refund balance will be burnt, so ",(0,a.jsx)(t.code,{children:"to"})," will be the null address instead of the refund address."]}),"\n",(0,a.jsxs)(t.p,{children:["For sponsor replacement, ",(0,a.jsx)(t.code,{children:"from"})," is set to the sponsor whitelist contract address (",(0,a.jsx)(t.code,{children:"0x0888000000000000000000000000000000000001"}),", i.e., ",(0,a.jsx)(t.code,{children:"cfx:aaejuaaaaaaaaaaaaaaaaaaaaaaaaaaaaegg2r16ar"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["For staking deposit, ",(0,a.jsx)(t.code,{children:"to"})," is set to the staking interest contract address (",(0,a.jsx)(t.code,{children:"0x0888000000000000000000000000000000000002"}),", i.e., ",(0,a.jsx)(t.code,{children:"cfx:aaejuaaaaaaaaaaaaaaaaaaaaaaaaaaaajrwuc9jnb"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["For staking withdraw, two ",(0,a.jsx)(t.code,{children:"InternalTransferAction"})," traces will be recorded. The first is for withdrawing the original staked balance (",(0,a.jsx)(t.code,{children:"from"})," is set to the staking interest contract address), and the second is for withdrawing the staking interest (",(0,a.jsx)(t.code,{children:"from"})," is set to the null address)."]}),"\n",(0,a.jsx)(t.h2,{id:"discussion-of-failure",children:"Discussion of Failure"}),"\n",(0,a.jsxs)(t.p,{children:["For ",(0,a.jsx)(t.code,{children:"Call"})," or ",(0,a.jsx)(t.code,{children:"Create"})," executed within contract execution, it is only recorded after the actual trap is triggered during execution, and the result is recorded after the trap is processed. If the transaction/instruction fails without triggering the trap (for example, the sender does not have enough balance, reentrancy is detected, or the stack has reached the max depth), no trace will be recorded."]}),"\n",(0,a.jsxs)(t.p,{children:["For ",(0,a.jsx)(t.code,{children:"Call"})," or ",(0,a.jsx)(t.code,{children:"Create"}),' triggered by the original transaction, the trace is only recorded after passing the preliminary checks. First, traces will only be recorded for "executed" transactions, so if the nonce does not match, this transaction will not be executed and there will be no trace. If the transaction is executed (the nonce of the sender increases), but the sender does not have enough balance to execute the transactions, there are also no traces. For ',(0,a.jsx)(t.code,{children:"Create"}),", if the to-be-created contract address was created before and has code, we will also return directly without recording traces."]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>c});var a=n(67294);const r={},s=a.createContext(r);function c(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);