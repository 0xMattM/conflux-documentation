"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[3556],{46139:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=n(85893),a=n(11151);const o={displayed_sidebar:"generalSidebar"},s="MethodId Optimization",c={id:"general/build/smart-contracts/gas-optimization/methodId",title:"MethodId Optimization",description:"When transactions are executed by the Ethereum Virtual Machine (EVM), the accompanying calldata, which specifies the contract function to be executed, incurs gas fees. These fees are calculated based on the calldata size, with 0 bytes costing 4 gas units and non-0 bytes costing 16 gas units. This pricing structure encourages the efficient use of calldata to reduce transaction costs, especially in contracts with high transaction volumes or complex operations.",source:"@site/docs/general/build/smart-contracts/gas-optimization/methodId.md",sourceDirName:"general/build/smart-contracts/gas-optimization",slug:"/general/build/smart-contracts/gas-optimization/methodId",permalink:"/docs/general/build/smart-contracts/gas-optimization/methodId",draft:!1,unlisted:!1,editUrl:"https://github.com/Conflux-Chain/conflux-documentation/edit/main/docs/general/build/smart-contracts/gas-optimization/methodId.md",tags:[],version:"current",frontMatter:{displayed_sidebar:"generalSidebar"},sidebar:"generalSidebar",previous:{title:"Local Variables",permalink:"/docs/general/build/smart-contracts/gas-optimization/local-variables"},next:{title:"Variable Packing",permalink:"/docs/general/build/smart-contracts/gas-optimization/packing"}},r={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"methodid-optimization",children:"MethodId Optimization"}),"\n",(0,i.jsx)(t.p,{children:"When transactions are executed by the Ethereum Virtual Machine (EVM), the accompanying calldata, which specifies the contract function to be executed, incurs gas fees. These fees are calculated based on the calldata size, with 0 bytes costing 4 gas units and non-0 bytes costing 16 gas units. This pricing structure encourages the efficient use of calldata to reduce transaction costs, especially in contracts with high transaction volumes or complex operations."}),"\n",(0,i.jsx)(t.p,{children:"The first four bytes of calldata, known as the MethodId, identify the specific contract function to be executed. Optimizing function names to increase the number of 0 bytes in the MethodId can reduce gas costs. This optimization is particularly impactful for frequently called functions, as it directly affects the overall gas efficiency of contract interactions."}),"\n",(0,i.jsxs)(t.p,{children:["We can optimize function names using this tool: ",(0,i.jsx)(t.a,{href:"https://emn178.github.io/solidity-optimize-name/",children:"Online Function Name Optimizer"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Demo Code"})}),"\n",(0,i.jsxs)(t.p,{children:["Below are examples of standard function calls and their optimized counterparts using ",(0,i.jsx)(t.strong,{children:"methodId optimization"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"contract ExampleContract {\n    // gas: 5285\n    function exampleFunction() external {\n    }\n}\n\ncontract OptimizedExampleContract {\n    // gas: 5265\n    function exampleFunction_X8p() external {\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Recommendations for gas optimization:"}),"\n",(0,i.jsx)(t.p,{children:"\ud83c\udf1f By refining function names to maximize the occurrence of 0 bytes in the MethodId, we can decrease the gas expenses. (It's also important to note that this approach can affect code readability to some extent.)"})]})}function u(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>s});var i=n(67294);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);