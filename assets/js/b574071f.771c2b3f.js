"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[9129],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=i,m=u["".concat(c,".").concat(p)]||u[p]||h[p]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1951:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={id:"transaction_explain",title:"Transaction Explanation",keywords:["transaction"]},r=void 0,s={unversionedId:"learn/conflux-basics/transactions/transaction_explain",id:"learn/conflux-basics/transactions/transaction_explain",title:"Transaction Explanation",description:"Sending a transaction is the only way to store or update data on the blockchain. Whether it is sending CFX or updating a contract state, it can only be achieved through transactions.",source:"@site/docs/learn/conflux-basics/transactions/my-first-transaction.md",sourceDirName:"learn/conflux-basics/transactions",slug:"/learn/conflux-basics/transactions/transaction_explain",permalink:"/docs/learn/conflux-basics/transactions/transaction_explain",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/conflux-basics/transactions/my-first-transaction.md",tags:[],version:"current",frontMatter:{id:"transaction_explain",title:"Transaction Explanation",keywords:["transaction"]},sidebar:"tutorialSidebar",previous:{title:"Transactions",permalink:"/docs/category/transactions"},next:{title:"Transaction Stages",permalink:"/docs/learn/conflux-basics/transactions/transaction_stage"}},c={},l=[{value:"How to construct a transaction",id:"how-to-construct-a-transaction",level:2},{value:"Basic fields",id:"basic-fields",level:3},{value:"nonce",id:"nonce",level:3},{value:"Fee-related fields",id:"fee-related-fields",level:3},{value:"data",id:"data",level:3},{value:"Other",id:"other",level:3},{value:"Transaction encoding and signature",id:"transaction-encoding-and-signature",level:2},{value:"How to check transaction details and status",id:"how-to-check-transaction-details-and-status",level:2},{value:"How to determine if a transaction is confirmed",id:"how-to-determine-if-a-transaction-is-confirmed",level:2},{value:"Reasons for transaction failure",id:"reasons-for-transaction-failure",level:2},{value:"Rejected by RPC",id:"rejected-by-rpc",level:3},{value:"Stuck in the transaction pool",id:"stuck-in-the-transaction-pool",level:3},{value:"Execution failed",id:"execution-failed",level:3},{value:"Differences between Conflux and Ethereum",id:"differences-between-conflux-and-ethereum",level:2}],d={toc:l};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sending a transaction is the only way to store or update data on the blockchain. Whether it is sending CFX or updating a contract state, it can only be achieved through transactions.\nSending a transaction involves three phases: transaction construction, signing, and sending. Usually, the SDK of each language will provide a packaged method that can be called directly.\nHowever, if you want to know more low-level details, or if you encounter problems when sending transactions, this article may be helpful."),(0,i.kt)("h2",{id:"how-to-construct-a-transaction"},"How to construct a transaction"),(0,i.kt)("p",null,"To construct a transaction, first, you need to prepare the various fields of the transaction, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gas")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gasPrice")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"storageLimit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chainId")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epochHeight"))),(0,i.kt)("h3",{id:"basic-fields"},"Basic fields"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"from"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"to"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," are basic fields of a transaction that correspond to the ",(0,i.kt)("inlineCode",{parentName:"p"},"originating account"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"destination account"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," of the transaction, respectively."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"from")," is fairly easy to determine. You can simply select an external account (non-contract account) address with CFX balance. If the destination account of the transaction is a contract that is sponsored, the initiating account does not even require a CFX balance. The balance of the account can be queried through the RPC ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getBalance")," RPC method."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"to")," is the destination account of the transaction: if you just want to initiate a CFX transfer, then ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," can be directly set as the CFX destination account; if you need to change the contract status, ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," needs to be set as the contract address; if you are deploying a new contract, ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," is left blank."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"value")," represents the CFX transfer amount of a transaction, and it needs to set an integer with the unit of Drip."),(0,i.kt)("h3",{id:"nonce"},"nonce"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," is the number of transactions sent by an account. In other words, it is the execution sequence number of transactions sent by an account. It can be queried through the RPC method ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getNextNonce"),". It has the following characteristics:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The execution of transactions on the blockchain is in the order of nonce from small to large."),(0,i.kt)("li",{parentName:"ol"},"The initial value of nonce is 0, and the nonce will be increased by 1 for every transaction execution."),(0,i.kt)("li",{parentName:"ol"},"The nonce cannot be reused."),(0,i.kt)("li",{parentName:"ol"},"Nonce cannot be skipped: Assume that the current nonce of an account is n. If the nonce of the transaction is m such that m > n, then the transaction will not be executed until all transactions with nonce < m have been executed."),(0,i.kt)("li",{parentName:"ol"},"After the transaction is sent through the ",(0,i.kt)("inlineCode",{parentName:"li"},"cfx_sendRawTransaction")," method, it will not be executed immediately. You need to wait for the miner to pack it first. After being packed, it will be executed after a delay of 5 Epochs. After the transaction is executed, the nonce of the account will increase by one.")),(0,i.kt)("p",null,"Setting the nonce correctly is the key to a smooth transaction execution. Many developers will encounter the situation when the transaction is sent successfully but the execution result (receipt) does not exist. (This suggests that the transaction has not been executed. In most cases, this is due to inadvertently skipping a nonce. A skipped nonce will cause the transaction to be stuck in the transaction pool while awaiting for the previous transaction to be executed."),(0,i.kt)("p",null,"When using the SDK to construct a transaction, the nonce does not need to be set manually. The SDK will automatically call ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getNonce")," to obtain the nonce. However, if you want to send transactions in batches, using ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getNonce")," to obtain nonce will cause the reuse of nonce due to the difference in time consumed for transaction send and execution. This means that, if you send multiple transactions through the SDK simultaneously, they will all use the same nonce and only one of them will be executed. (It takes a while for the transaction to be executed after it is sent while sending the transactions doesn't require much time to process.) In this case, the developer needs to manage the nonce manually: record the hash of the transaction for each transaction sent, add one to the nonce, and use the updated nonce to construct the transaction."),(0,i.kt)("h3",{id:"fee-related-fields"},"Fee-related fields"),(0,i.kt)("p",null,"After the transactions are sent to the network, they are packaged and executed by miners. Miners will charge a service fee for packaging transactions. This provides incentives for miners to participate in mining and keep the network running.\nIn the Conflux network, transaction fees are paid in CFX. Fees are specified by the transaction initiator through the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," fields of the transaction."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"gas")," field is used to specify the upper limit of the maximum amount of gas that can be paid when a transaction is executed. This can be understood as the ",(0,i.kt)("inlineCode",{parentName:"p"},"limit")," of the gas that can be consumed by the transaction execution, that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit"),". When a miner executes a transaction, many instructions are executed internally, and different instructions consume different amounts of gas. If the total amount of gas consumed by the transaction exceeds the ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit")," specified by the transaction,  the execution of the transaction will fail. Regular CFX transfer transactions consume ",(0,i.kt)("inlineCode",{parentName:"p"},"21000")," gas. If interacting with a contract, the gas consumption will depend on the complexity of the contract's corresponding bytecode, which can be estimated using the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_estimateGasAndCollateral")," method. This method will return two gas-related fields:  gasUsed and ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit"),". The gasUsed is the actual amount of gas consumed by the transaction execution at the time of estimation. The ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas")," value set by transaction sending recommendation (slightly larger than ",(0,i.kt)("inlineCode",{parentName:"p"},"gasUsed"),") to avoid transaction failure caused by inaccurate (smaller) estimation. Only 25% of the exceeding actual gas (compared to the ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit")," value) will be returned. Therefore it is important to set the transaction ",(0,i.kt)("inlineCode",{parentName:"p"},"gasLimit")," appropriately."),(0,i.kt)("p",null,"To help miners estimate their revenue with reasonable accuracy, at most 25% of the overall ",(0,i.kt)("inlineCode",{parentName:"p"},"gas")," provided will be refunded. In other words, ",(0,i.kt)("strong",{parentName:"p"},"the sender needs to pay at least 75% of the gas costs, even if the actual transaction execution consumed much less gas"),". Therefore it is important to set the transaction gas limit appropriately."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," is the amount of CFX that the transaction initiator is willing to pay per gas. The unit is Drip. Thus, the calculation of the upfront gas fee charged for transaction execution is gas * gasPrice. As mentioned before, up to 25% of this fee can be refunded to the sender."),(0,i.kt)("p",null,"Miners will pack transactions with higher payouts first. If the network is congested, you can speed up the packing of transactions by increasing the ",(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," value. If the transaction is stuck for some reason, or if you want to speed up the packing of the transaction, try raising ",(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," and resending the transaction with the same nonce. Fullnode provides an RPC method ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_gasPrice")," that returns a reasonable ",(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," value based on the current network conditions."),(0,i.kt)("p",null,"In addition to transaction fees, in the Conflux network, if new storage space is occupied during the transaction's execution, some CFX are pledged for that space occupation. The annualized %4 interest generated by the pledged CFX will be paid to the miners to subsidize their storage costs. If the occupied space is released, the pledged CFX will be released and returned to the sender of the transaction. For every 1KB of new space taken, 1 CFX is pledged. The ",(0,i.kt)("inlineCode",{parentName:"p"},"storageLimit")," field is used to specify the upper limit of the space (in bytes) occupied by a transaction execution. If the transaction tries to occupy more storage than allowed by the storageLimit field, the transaction fails and no CFX is pledged."),(0,i.kt)("p",null,"Therefore, when sending a transaction, you need to ensure the sending account has enough balance to pay: ",(0,i.kt)("inlineCode",{parentName:"p"},"value + storageLimit * (10^18/1024) + gas * gasPrice"),". If the balance is insufficient, instead of failing directly, the transaction may get stuck in the transaction pool and get executed once the sender's balance is sufficient. If the transaction is interacting with the contract, and the contract has a sponsor, you only need to ensure that the balance is enough to pay for value."),(0,i.kt)("p",null,"The current SDK automatically calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_estimateGasAndCollateral")," method to set reasonable ",(0,i.kt)("inlineCode",{parentName:"p"},"gas"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"storageLimit")," values for the transaction and the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_gasPrice")," method to set a reasonable ",(0,i.kt)("inlineCode",{parentName:"p"},"gasPrice")," value. Of course, the users can also specify more reasonable values manually."),(0,i.kt)("h3",{id:"data"},"data"),(0,i.kt)("p",null,"The data field of the transaction can be left blank or set to a hex-encoded byte array. This can be roughly categorized into three situations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Regular CFX transfer transaction: The ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," field is usually blank, but hex-encoded data can be set as a transaction remark or postscript."),(0,i.kt)("li",{parentName:"ul"},"Contract deployment transaction: ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," needs to be set as the contract's bytecode and the parameters of the constructor (if any)"),(0,i.kt)("li",{parentName:"ul"},"Contract call transaction: The ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," field is used to store the input data for the contract to call. The data is usually the contract method and data after parameter abi encoding. (When sending CFX to a contract, the data field is usually left blank)")),(0,i.kt)("p",null,"Smart contracts are usually written in high-level contract development languages (Solidity, vyper). You can use a compiler to obtain bytecode and abi. SDK will provide abi encoding methods for the encoding of the contract method call (encoding the method name and parameters)."),(0,i.kt)("h3",{id:"other"},"Other"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"chainId")," is used to identify a chain. The current chainId of the Conflux Tethys network is ",(0,i.kt)("inlineCode",{parentName:"p"},"1029"),", while that of the Conflux testnet is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". The chainId is included in the transaction mainly to prevent transaction replay attacks.  This field usually does not need to be filled manually. SDK will automatically obtain the current RPC chainId through the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getStatus")," method."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"epochHeight")," is used to specify the target Epoch range for a transaction. Transactions will only be executed in the range of ","[Te \u2212 100000, Te + 100000]",". If the Epoch of the current chain exceeds that range, the transaction will be discarded. SDK also sets this field to the current Epoch obtained by the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_epochNumber")," method automatically."),(0,i.kt)("h2",{id:"transaction-encoding-and-signature"},"Transaction encoding and signature"),(0,i.kt)("p",null,"After the fields of the transaction are determined, transactions need to be rlp encoded in a specific format, and the encoded keccak256 hash will be signed by the private key of the sending account. Finally, a rawTransaction will be assembled. The rawTransaction can be sent to the Conflux network through the ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_sendRawTransaction")," method, awaiting to be packaged and executed by the miners."),(0,i.kt)("p",null,"The specific steps are as follows (take js-conflux-sdk as an example):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse each field of the transaction into buffer"),(0,i.kt)("li",{parentName:"ol"},"Assemble each field into an array or tuple in the order of ",(0,i.kt)("inlineCode",{parentName:"li"},"(nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data)")," and perform rlp encoding."),(0,i.kt)("li",{parentName:"ol"},"Perform the ",(0,i.kt)("inlineCode",{parentName:"li"},"keccak256")," operation on the encoded result to obtain a hash"),(0,i.kt)("li",{parentName:"ol"},"Use the private key of the sending account to perform the ecdsaSign signature operation to the hash obtained in the previous step. After that, r, s, v are obtained."),(0,i.kt)("li",{parentName:"ol"},"Assemble all the information according to ",(0,i.kt)("inlineCode",{parentName:"li"},"((nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data), v, r, s)")," and perform rlp encoding."),(0,i.kt)("li",{parentName:"ol"},"Finally, convert the encoded buffer in the previous step into a hex string, and then, you will get a rawTransaction that can be sent directly.")),(0,i.kt)("h2",{id:"how-to-check-transaction-details-and-status"},"How to check transaction details and status"),(0,i.kt)("p",null,"After the transaction is successfully sent, it will first be placed in the transaction pool. When the packaging conditions are met, the transaction will be packaged by the miner into the latest block. At this time, you can query the information and status of the transaction through ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getTransactionByHash"),"\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"status")," field of the returned result indicates the execution status of the transaction:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null"),": not executed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0x0"),": Execution successful"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0x1"),": Execution failed, transaction was reverted"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0x2"),": The transaction was skipped")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "jsonrpc": "2.0",\n    "result": {\n        "blockHash": "0x398879d9e7d37e2cc87af268fcd2207a689e2e84986e9251a5343dafca3d93b7",\n        "chainId": "0x405",\n        "contractCreated": null,\n        "data": "0x",\n        "epochHeight": "0xd03609",\n        "from": "CFX:TYPE.USER:AAKETJH9TKJ5G2K4ZX3KFVB9VKKU8NR956N0EN4FHE",\n        "gas": "0x5208",\n        "gasPrice": "0x2540be400",\n        "hash": "0xa76efec071e0779785b6653aebb2382a5e460b60a163a1b166df3c8164cec6d9",\n        "nonce": "0xa08d9",\n        "r": "0x38e661ad41790c069a4795df21eade5ef9605dbcbdfd5dabbb0dc322e833e4c1",\n        "s": "0x66ca875464c554261033f4522281d564bdba4f0189d357579dcbf2b1ed98936b",\n        "status": "0x0",\n        "storageLimit": "0x0",\n        "to": "CFX:TYPE.USER:AATT0JGE4J70V4H0Z43VJ9M29ZJ7ASNS0YA238MGZC",\n        "transactionIndex": "0x1",\n        "v": "0x0",\n        "value": "0xde0b93b7d70bec0"\n    },\n    "id": "15922956697249514502"\n}\n')),(0,i.kt)("p",null,"The transaction will not be executed immediately after it's packaged, and the transaction's ",(0,i.kt)("inlineCode",{parentName:"p"},"status")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," at that point. After a delay of 4 Epochs, the status of the transaction would change to ",(0,i.kt)("inlineCode",{parentName:"p"},"0x0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0x1"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"0x2"),". (",(0,i.kt)("inlineCode",{parentName:"p"},"0x0")," for success, ",(0,i.kt)("inlineCode",{parentName:"p"},"0x1")," for failure, and ",(0,i.kt)("inlineCode",{parentName:"p"},"0x2")," for skip.)"),(0,i.kt)("p",null,"You can also get the transaction execution receipt through ",(0,i.kt)("inlineCode",{parentName:"p"},"cfx_getTransactionReceipt"),". This can only be obtained after the transaction has been executed, otherwise, it will return ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". The receipt contains a field ",(0,i.kt)("inlineCode",{parentName:"p"},"outcomeStatus")," which can also be used to determine whether the transaction is executed successfully: ",(0,i.kt)("inlineCode",{parentName:"p"},"0x0")," indicates success, others indicate failure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "jsonrpc": "2.0",\n    "result": {\n        "blockHash": "0x398879d9e7d37e2cc87af268fcd2207a689e2e84986e9251a5343dafca3d93b7",\n        "contractCreated": null,\n        "epochNumber": "0xd0360f",\n        "from": "CFX:TYPE.USER:AAKETJH9TKJ5G2K4ZX3KFVB9VKKU8NR956N0EN4FHE",\n        "gasCoveredBySponsor": false,\n        "gasFee": "0xbefe6f672000",\n        "gasUsed": "0x5208",\n        "index": "0x1",\n        "logs": [],\n        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",\n        "outcomeStatus": "0x0",\n        "stateRoot": "0x8c05b8eb6b9dc69f2e7bb235621487022e694ce3969202b94e76227673a0b86b",\n        "storageCollateralized": "0x0",\n        "storageCoveredBySponsor": false,\n        "storageReleased": [],\n        "to": "CFX:TYPE.USER:AATT0JGE4J70V4H0Z43VJ9M29ZJ7ASNS0YA238MGZC",\n        "transactionHash": "0xa76efec071e0779785b6653aebb2382a5e460b60a163a1b166df3c8164cec6d9",\n        "txExecErrorMsg": null\n    },\n    "id": "15922956697249514502"\n}\n')),(0,i.kt)("h2",{id:"how-to-determine-if-a-transaction-is-confirmed"},"How to determine if a transaction is confirmed"),(0,i.kt)("p",null,"In the blockchain, a block can be reverted after being executed. Accordingly, a transaction can also be reversed after being executed. The status of the transaction can only be considered final once the block has been confirmed.\nThere are two ways to determine whether a transaction (block) is confirmed in Conflux:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the latest ",(0,i.kt)("inlineCode",{parentName:"li"},"confirmed epochNumber")," of the network is greater than the epochNumber of the transaction, the transaction is confirmed. By calling ",(0,i.kt)("inlineCode",{parentName:"li"},"cfx_epochNumber")," method and passing ",(0,i.kt)("inlineCode",{parentName:"li"},"latest_confirmed")," parameter, you can obtain the latest confirmed ",(0,i.kt)("inlineCode",{parentName:"li"},"epochNumber"),". epochNumber of the transaction is in its receipt. "),(0,i.kt)("li",{parentName:"ol"},"You can obtain a block's confirmation risk value by calling the method ",(0,i.kt)("inlineCode",{parentName:"li"},"cfx_getConfirmationRiskByHash"),". If ",(0,i.kt)("em",{parentName:"li"},"risk/MAX_UINT256 is less than 1e-8"),", the block is confirmed and will not be reverted. The block hash of the transaction can be obtained through ",(0,i.kt)("inlineCode",{parentName:"li"},"cfx_getTransactionByHash"),".")),(0,i.kt)("p",null,"In Conflux, usually, a block can be confirmed after 50 epochs (within one minute). If the transaction involves a large amount, you might need to wait for more epochs according to the situation."),(0,i.kt)("h2",{id:"reasons-for-transaction-failure"},"Reasons for transaction failure"),(0,i.kt)("p",null,"Based on the stage in which the transaction fails, there are three categories of failures:"),(0,i.kt)("h3",{id:"rejected-by-rpc"},"Rejected by RPC"),(0,i.kt)("p",null,"The sending transaction is directly rejected by RPC. The reason for rejection can be found in the ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," field of RPC Response."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Invalid parameters: tx', 'data': '\"Failed imported to deferred pool: Tx with same nonce already inserted. To replace it, you need to specify a gas price > 5")," The error code indicates that the same nonce has been used in the transaction pool and cannot be reused. However, you can replace an existing transaction by sending a transaction with the same nonce but higher gas price."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"'Invalid parameters: tx', 'data': '\"Transaction 0x2004b0aea956e8cfad601cd6daad5630c1a95624bad446d1966895973325136c is discarded due to a too stale nonce")," This indicates that the same nonce used has been used in history and cannot be used again."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Sending transactions to invalid address. The first four bits must be 0x0 (built-in/reserved), 0x1 (user-account), or 0x8 (contract).")," This indicates that the receiving address of the transaction is wrong."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Transaction {:?} is discarded due to in too distant future")," This indicates that the transaction is using a nonce that is too large for the account's current nonce"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"tx already exist")," This indicates that the transaction already exists.")),(0,i.kt)("p",null,"Sometimes, the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," of Response will also contain some error information. \uff08This field is a hex-encoded string. The parsing method is: hex -> buffer -> UTF8 string\uff09"),(0,i.kt)("h3",{id:"stuck-in-the-transaction-pool"},"Stuck in the transaction pool"),(0,i.kt)("p",null,"The transaction is sent successfully but not be packaged. There are two possible reasons:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The skipped nonce is used, and the transaction of the previous nonce has not been generated or executed."),(0,i.kt)("li",{parentName:"ol"},"The account sending this transaction does not have enough balance to pay the transaction.")),(0,i.kt)("h3",{id:"execution-failed"},"Execution failed"),(0,i.kt)("p",null,"Execution failure is usually due to an error that occurred during the execution process of the contract, which then caused the transaction failure. Such errors are mostly caused by contract execution failures or errors returned when estimating gas cost through the estimate interface.\nYou can check the specific reason for the transaction failure in the ",(0,i.kt)("inlineCode",{parentName:"p"},"txExecErrorMsg")," under receipt:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"VmError(OutOfGas)")," The transaction specified gas fee is not enough"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"VmError(ExceedStorageLimit)")," The transaction specified upper-limit storage is not enough"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"NotEnoughCash")," Insufficient user balance"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Vm reverted, Reason provided by the contract: xxxx")," The contract execution failed with details provided. "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"VmError(BadInstruction xxxx)")," Contract deployment failed"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Vm reverted, xxxx")," The contract execution failed with no details provided.")),(0,i.kt)("h2",{id:"differences-between-conflux-and-ethereum"},"Differences between Conflux and Ethereum"),(0,i.kt)("p",null,"Compared to Ethereum ",(0,i.kt)("inlineCode",{parentName:"p"},"155 transaction"),", transactions through Conflux have several differences:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Two more fields: ",(0,i.kt)("inlineCode",{parentName:"li"},"storageLimit"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"epochNumber"),"."),(0,i.kt)("li",{parentName:"ul"},"The RLP encoding assembly method of the transaction is different. ",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"When compute transaction hash the RLP structure is ",(0,i.kt)("inlineCode",{parentName:"li"},"[nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data]")),(0,i.kt)("li",{parentName:"ol"},"When assemble rawTx the RLP structure is ",(0,i.kt)("inlineCode",{parentName:"li"},"[[nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data], v, r, s]")))),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," value signed by ecdsaSign will not be specifically modified in Conflux; while In Ethereum, there will be some special treatments to the v value."),(0,i.kt)("li",{parentName:"ul"},"Finally, while Ethereum nodes directly reject transactions if the sender has insufficient balance, Conflux nodes accept such transactions but only pack them info blocks once the user's balance can cover it")))}h.isMDXComponent=!0}}]);