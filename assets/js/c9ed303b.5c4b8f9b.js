"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[3287],{49346:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=t(85893),o=t(11151);const r={displayed_sidebar:"generalSidebar"},i="Rigorous Testing Tools for Conflux",a={id:"general/build/node-development/rigorous-testing",title:"Rigorous Testing Tools for Conflux",description:"Ensuring the correctness of a blockchain system like Conflux is a challenging",source:"@site/docs/general/build/node-development/rigorous-testing.md",sourceDirName:"general/build/node-development",slug:"/general/build/node-development/rigorous-testing",permalink:"/docs/general/build/node-development/rigorous-testing",draft:!1,unlisted:!1,editUrl:"https://github.com/Conflux-Chain/conflux-documentation/edit/main/docs/general/build/node-development/rigorous-testing.md",tags:[],version:"current",frontMatter:{displayed_sidebar:"generalSidebar"},sidebar:"generalSidebar",previous:{title:"The Conflux Consensus Layer Design and Implementation",permalink:"/docs/general/build/node-development/consensus-design"},next:{title:"Stratum Protocol in Conflux-Rust",permalink:"/docs/general/build/node-development/stratum"}},c={},l=[{value:"Unit Tests and Integration Tests",id:"unit-tests-and-integration-tests",level:2},{value:"Consensus Fuzzing Tool",id:"consensus-fuzzing-tool",level:2},{value:"Random Tracing Test",id:"random-tracing-test",level:2},{value:"Transaction Propagation and Performance Test",id:"transaction-propagation-and-performance-test",level:2},{value:"Storage Benchmark Test",id:"storage-benchmark-test",level:2},{value:"Consensus Performance Benchmark Tool",id:"consensus-performance-benchmark-tool",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"rigorous-testing-tools-for-conflux",children:"Rigorous Testing Tools for Conflux"}),"\n",(0,s.jsx)(n.p,{children:"Ensuring the correctness of a blockchain system like Conflux is a challenging\ntask. The Conflux Rust implementation repository comes with several rigorous\ntesting tools and scripts."}),"\n",(0,s.jsx)(n.p,{children:"Note that in some terminals, the default maximum number of open file\ndescriptors may not be enough. This is especially true if you are using Mac\nwith its default zsh terminal. You will need to change the limit to a larger\nnumber as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ ulimit -n 22288\n"})}),"\n",(0,s.jsx)(n.h2,{id:"unit-tests-and-integration-tests",children:"Unit Tests and Integration Tests"}),"\n",(0,s.jsxs)(n.p,{children:["Unit tests come together with the rust code. It can be invoked via ",(0,s.jsx)(n.code,{children:"cargo test --release --all"})," after Conflux being complied from the source code. See the\n",(0,s.jsx)(n.a,{href:"https://conflux-chain.github.io/conflux-doc/get_started/",children:"Getting Started"}),"\npage for more information. Integration tests are python test scripts ended with\n",(0,s.jsx)(n.code,{children:"_test.py"})," in the ",(0,s.jsx)(n.code,{children:"tests/scripts"})," directory. After compiled the ",(0,s.jsx)(n.em,{children:"release"}),"\nversion of the Conflux from code. One can run ",(0,s.jsx)(n.code,{children:"tests/test_all.py"})," to run all\nintegration tests together. These tests are executed routinely for every commit\nto the Conflux Rust implementation."]}),"\n",(0,s.jsx)(n.h2,{id:"consensus-fuzzing-tool",children:"Consensus Fuzzing Tool"}),"\n",(0,s.jsxs)(n.p,{children:["Inside the directory ",(0,s.jsx)(n.code,{children:"core/benchmark/consensus/test"}),", there is a random fuzzing\ntool for the consensus component. It works as follows.\n",(0,s.jsx)(n.code,{children:"core/benchmark/consensus/test/gen-random-graph.cpp"})," is a slow C++\nimplementation of the Conflux TreeGraph consensus algorithm together with a\nrandom graph generator that generates random TreeGraph blocks in a special\nformat. ",(0,s.jsx)(n.code,{children:"consensus_bench"})," is capable of processing this input format, run the\nConflux consensus, and compare the results with the slow C++ implementation.\n",(0,s.jsx)(n.code,{children:"iter-gen-random.py"})," is a python script that iteratively invoke the\ngeneration-processing-comparing process. To run this fuzzing tool:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ cd core/benchmark/consensus/test\n$ g++ -O2 -o gen-random-graph gen-random-graph.cpp\n$ ./iter-gen-random.py 10000 3 30 10 10 100\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The python script will not stop until it finds an error or you manually\nterminate it. If the python script finds an error, the ",(0,s.jsx)(n.code,{children:"rand.in"})," file will\ncorrespond to the bug triggering input for the ",(0,s.jsx)(n.code,{children:"consensus_bench"})," program. The\nsix parameters passed to the python scripts corresponds to the number of\nrandomly generated block per test case, the\n",(0,s.jsx)(n.code,{children:"TIMER_CHAIN_BLOCK_DIFFICULTY_RATIO"})," parameter, the ",(0,s.jsx)(n.code,{children:"TIMER_CHAIN_BETA"}),"\nparameter, the ",(0,s.jsx)(n.code,{children:"ADAPTIVE_WEIGHT_BETA"})," parameter, the\n",(0,s.jsx)(n.code,{children:"HEAVY_BLOCK_DIFFICULTY_RATIO"})," parameter, the ",(0,s.jsx)(n.code,{children:"ERA_EPOCH_COUNT"})," parameter,\nrespectively. You can pass any legitimate consensus parameter to the python\nscript. These numbers are default that we empirically find them useful for\ndetecting bugs."]}),"\n",(0,s.jsx)(n.p,{children:"The python script will also print out the processing speed of the consensus\ngraph in the test. The expected speed is ~1000 blocks per second (on a Mac Book\nPro 2019 laptop) and ~350 blocks per second on m5a.xlarge. If the reported\nspeed is significantly lower than expected, it typically means a potential\nperformance issue. For every release, we execute this fuzzing for at least one\nhour using the default parameters."}),"\n",(0,s.jsxs)(n.p,{children:["Note that if you terminate this script brutally (which you will like do). It\nleaves two to three temporary directories with the ",(0,s.jsx)(n.code,{children:"__"})," prefix and ",(0,s.jsx)(n.code,{children:"sqlite_db"}),".\nYou should remove these directories manually."]}),"\n",(0,s.jsx)(n.h2,{id:"random-tracing-test",children:"Random Tracing Test"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tests/conflux_tracing.py"})," is a random testing script with the failure\ninjection capability. It will start a Conflux network with a fixed number of\nnodes and inject node crashes, db crashes, and node restarts during. During the\nrunning, it keep fetches states from different node and verify that these nodes\nhave the consensus for the TreeGraph and block state. To run Conflux tracing,\nyou need to first compile the release version of the Conflux Rust implementation\nfrom the source code. Then you can invoke the script as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ tests/conflux_tracing.py run\n"})}),"\n",(0,s.jsx)(n.p,{children:"The python script will then start 10 different instances together with a mock\ninstance. It will run non-stop until it finds an error (inconsistent state or\nunexpected crash). For every release, we execute this tracing script for at\nleast one hour."}),"\n",(0,s.jsxs)(n.p,{children:["In case of errors, it will generate trace files ",(0,s.jsx)(n.code,{children:"snapshot*.json"})," and\n",(0,s.jsx)(n.code,{children:"txs*.json"})," to help diagnose the issue. Note that if you terminate this script\nbrutally (which you will likely do). It also generates these files so you may\nwant to clean them manually."]}),"\n",(0,s.jsx)(n.h2,{id:"transaction-propagation-and-performance-test",children:"Transaction Propagation and Performance Test"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tests/scripts/one_click.sh"})," together with the remaining bash scripts in the\nsame directory provide an automatic deployment of Conflux network on AWS for\ntesting the simple payment TPS and transaction pool performance. You can run\nthis test as follows:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"First you need to download and install AWS CLI tools. Properly configure the\nAWS credential for the CLI tool."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Make your default public key registered as a named key pair in ",(0,s.jsx)(n.em,{children:"the us-west-2 region"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Decide the branch of the Conflux repo you want to test. Note that this\nscript pulls the source code from a GitHub repo that contains the Conflux rust\nimplementation and compile them on the fly. You cannot run your local Conflux\ncopy with this script. If you do not specify the repo/branch name, it will pull\nfrom the official Conflux-rust repo from the GitHub."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Run the following command:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ cd tests/scripts\n$ ./one_click.sh key-pair-name 20 branch-name [repo-name]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will start 20 instances at the us-west-2 region together with a random\ntransaction generator. It will take roughly 15 minutes to setup the experiments\nand then 20 minutes to finish the run. In the end, it will report the TPS\nperformance. The expected good TPS number is ~4000TPS. If you get a TPS number\nmuch lower than the expectation, there is a performance regression at the\ntransaction pool or at the storage layer. For every release, we run this script\nto test its performance."}),"\n",(0,s.jsx)(n.h2,{id:"storage-benchmark-test",children:"Storage Benchmark Test"}),"\n",(0,s.jsxs)(n.p,{children:["The storage layer in Conflux is often the performance bottleneck.\n",(0,s.jsx)(n.code,{children:"core/benchmark/storage"})," therefore contains a benchmark tool to measure the\nperformance of the storage layer, eliminating other layer from the execution.\nWe also converted Ethereum network history payment transactions (first ~4m\nblocks) as the benchmark traces. Here are steps to run the storage benchmark\ntest:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["From the AWS S3 ",(0,s.jsx)(n.code,{children:"conflux-storage-bench"})," bucket, download ",(0,s.jsx)(n.code,{children:"foundation.json"}),"\nand ",(0,s.jsx)(n.code,{children:"eth_from_0_to_4141811_txs.rlp.tar.gz"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Untar the rlp history file to obtain ",(0,s.jsx)(n.code,{children:"eth_from_0_to_4141811_txs.rlp"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Go to ",(0,s.jsx)(n.code,{children:"core/benchmark/storage"})," and run ",(0,s.jsx)(n.code,{children:"cargo build --release"})," to compile\nthe binary ",(0,s.jsx)(n.code,{children:"storage_bench"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Create a temporary directory ",(0,s.jsx)(n.code,{children:"tmp_storage_db"})," for holding the blockchain\ndatabase generated in the experiment."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Invoke the following command:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ cd core/benchmark/storage\n$ RUST_BACKTRACE=full target/release/storage_bench run -g /path/to/foundation.json -t /path/to/eth_from_0_to_4141811_txs.rlp -d /path/to/tmp_storage_db --txs_to_process 30000000 --skip 1156773812\n"})}),"\n",(0,s.jsx)(n.p,{children:"This command will process the first 30 million transactiosn from the parsed\nhistory file and then quit. It is a good idea to time the running time of this\ncommand for computing the achieved processing throughput of the storage layer.\nThe performance will largely depend on the quality of the underlying disk I/O.\nIn MacBook Pro 2019, the throughput is 25000-30000 TPS. In m5a.xlarge, the\nthroughput is 15000-20000 TPS. If the performance is lower than the\nexpectation, it indicates a potential regression at the storage layer. For\nevery relealse, we will run this test to check the storage layer performance."}),"\n",(0,s.jsx)(n.h2,{id:"consensus-performance-benchmark-tool",children:"Consensus Performance Benchmark Tool"}),"\n",(0,s.jsxs)(n.p,{children:["The consensus implementation is typically fast and can process close to one\nthousand blocks per second in the normal scenarios. However, if the TreeGraph\nis unstable and it contains a lot of forks, the consensus component may fail\nback to slow routines. Its performance under such unstable scenarios is\ncritical because it corresponds to the catch-up speed during DoS attacks.\n",(0,s.jsx)(n.code,{children:"tests/attack_bench"})," contains a list of python scripts to benchmark the\nconsensus performance under attack scenarios:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fork_same_height_merge.py"})," creates a unstable TreeGraph with roughly 95000\nblocks. In the TreeGraph, it has three branches and in each branch there are\nstar shape forks attached at a fixed height. It corresponds to one worst case\nscenario for the consensus procesing engine. The expected speed is ~70 blocks/s\non MacBook Pro 2019 and ~45 blocks/s on m5a.xlarge."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fork_same_height_hiding.py"})," tests the scenario where an attacker tries to\nactively mine at a fixed height, hides the mined blocks, and release them\ntogether. It measures the block generation capaiblity of the victim at this\nscenario. The expected generation speed is always faster than 1000 blocks in\nless than 1 minutes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fork_same_height_attack.py"})," tests a similar attack as 2 but the attacker\ndoes not hide the blocks. The expected generation speed is always faster than\n100 blocks in less than 10 seconds."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fork_chain_hiding.py"})," tests the scenario where an attacker tries to\nactively mine a separate chain, hides the mined blocks, and release them\ntogether. The expected generation speed of the victim is always faster than 100\nblocks in less than 10 seconds."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fork_chain_attack.py"})," tests a similar attack as 4 but the attacker does not\nhide the blocks. The expected generation speed of the victim is always faster\nthan 100 blocks in less than 10 seconds."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note that 2, 3, and 5 are long running test scripts and you can terminate the\nexecution after the speed stablizes. For every release, we run these scripts to\nmake sure that there is no performance regression."})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>i});var s=t(67294);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);