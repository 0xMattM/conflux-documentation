<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-general/build/node-development/consensus-design">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">The Conflux Consensus Layer Design and Implementation | Conflux Docs</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.confluxnetwork.org/docs/general/build/node-development/consensus-design"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="The Conflux Consensus Layer Design and Implementation | Conflux Docs"><meta data-rh="true" name="description" content="The Conflux consensus layer processes all incoming blocks received from the"><meta data-rh="true" property="og:description" content="The Conflux consensus layer processes all incoming blocks received from the"><link data-rh="true" rel="icon" href="/img/logo.svg"><link data-rh="true" rel="canonical" href="https://doc.confluxnetwork.org/docs/general/build/node-development/consensus-design"><link data-rh="true" rel="alternate" href="https://doc.confluxnetwork.org/docs/general/build/node-development/consensus-design" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.confluxnetwork.org/zh-CN/docs/general/build/node-development/consensus-design" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://doc.confluxnetwork.org/docs/general/build/node-development/consensus-design" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Conflux Docs RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Conflux Docs Atom Feed"><link rel="stylesheet" href="/assets/css/styles.fbfc37b9.css">
<link rel="preload" href="/assets/js/runtime~main.55012e2d.js" as="script">
<link rel="preload" href="/assets/js/main.c401082f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Conflux Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="Conflux Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">CONFLUXDOCS</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/general">General</a><a class="navbar__item navbar__link" href="/docs/core">Core</a><a class="navbar__item navbar__link" href="/docs/espace">eSpace</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/docs/general/build/node-development/consensus-design" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li><li><a href="/zh-CN/docs/general/build/node-development/consensus-design" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">中文（中国）</a></li></ul></div><a href="https://github.com/Conflux-Chain/conflux-documentation" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/general/">General</a><button aria-label="Toggle the collapsible sidebar category &#x27;General&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/general/conflux-basics/">Conflux Basics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Conflux Basics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/run-a-node">Run a Node</a><button aria-label="Toggle the collapsible sidebar category &#x27;Run a Node&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/mining--staking">Mining &amp; Staking</a><button aria-label="Toggle the collapsible sidebar category &#x27;Mining &amp; Staking&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/general/tutorials/">Tutorials</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorials&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/general/build/">Build</a><button aria-label="Toggle the collapsible sidebar category &#x27;Build&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/category/node-development">Node Development</a><button aria-label="Toggle the collapsible sidebar category &#x27;Node Development&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/general/build/node-development/consensus-design">The Conflux Consensus Layer Design and Implementation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/build/node-development/rigorous-testing">Rigorous Testing Tools for Conflux</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/build/node-development/stratum">Stratum Protocol in Conflux-Rust</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/build/node-development/sync">Block Synchronization Process</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/build/node-development/test-framework">Test Framework</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/build/node-development/trace-introduction">Introduction to Transaction Traces</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/tools">Tools</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tools&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/nfts">NFTs</a><button aria-label="Toggle the collapsible sidebar category &#x27;NFTs&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/general/faq/">FAQ</a><button aria-label="Toggle the collapsible sidebar category &#x27;FAQ&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/general/CONTRIBUTING">Contributing</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/core/">Core</a><button aria-label="Toggle the collapsible sidebar category &#x27;Core&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/espace/">eSpace</a><button aria-label="Toggle the collapsible sidebar category &#x27;eSpace&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/general/"><span itemprop="name">General</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/general/build/"><span itemprop="name">Build</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/node-development"><span itemprop="name">Node Development</span></a><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">The Conflux Consensus Layer Design and Implementation</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>The Conflux Consensus Layer Design and Implementation</h1><p>The Conflux consensus layer processes all incoming blocks received from the
synchronization layer, produces the total order of blocks based on the Conflux
GHAST consensus algorithm, and invokes the underlying <strong>transaction execution
engine</strong> to run transactions in the determined order. It provides the
information necessary to assist <strong>block generator</strong> to prepare the block skeleton of new
blocks. It also notifies the <strong>transaction pool</strong> about processed transactions
so that the pool can make better transaction selection decisions. </p><p>This document is to provide a high-level overview for readers who want to
understand the rust implementation of the Conflux consensus layer (in directory
core/src/consensus). For more implementation details, see inlined comments in
the code. For more information about the Conflux consensus algorithm, see
Conflux Protocol Specification and Conflux paper (<a href="https://arxiv.org/abs/1805.03870" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1805.03870</a>). </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-goals">Design Goals<a href="#design-goals" class="hash-link" aria-label="Direct link to Design Goals" title="Direct link to Design Goals">​</a></h2><p>The consensus layer has the following design goals. </p><ol><li><p>Process new blocks in the background following the consensus algorithm
consistently.</p></li><li><p>We want to minimize the memory usage of each block in the consensus graph.
Even with the checkpoint mechanism, the graph will contain 300K-500K blocks in
the normal case and more than 1M blocks when facing liveness attacks. This may
stress the memory.</p></li><li><p>We want to process each block fast. Because full/archive nodes have to
process every block from the <em>original genesis</em> when they catch up with the
network from scratch, fast block process is important to keep the catch up
period short.</p></li><li><p>Robust against potential attacks. Malicious attackers may generate bad
blocks at arbitrary positions in the TreeGraph.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="structures-and-components">Structures and Components<a href="#structures-and-components" class="hash-link" aria-label="Direct link to Structures and Components" title="Direct link to Structures and Components">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensusgraph">ConsensusGraph<a href="#consensusgraph" class="hash-link" aria-label="Direct link to ConsensusGraph" title="Direct link to ConsensusGraph">​</a></h3><p><code>ConsensusGraph</code> (core/src/consensus/mod.rs) is the main struct of the
consensus layer. The synchronization layer constructs <code>ConsensusGraph</code> with a
<code>BlockDataManager</code> which stores all block metadata information on disk.
<code>ConsensusGraph::on_new_block()</code> is the key function to send new blocks to the
<code>ConsensusGraph</code> struct to process. It also provides a set of public functions
to query the status of blocks/transactions. This should be the main interface
with which other components interact.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensusgraphinner">ConsensusGraphInner<a href="#consensusgraphinner" class="hash-link" aria-label="Direct link to ConsensusGraphInner" title="Direct link to ConsensusGraphInner">​</a></h3><p><code>ConsensusGraphInner</code> (core/src/consensus/consensus_inner/mod.rs) is the inner
structure of <code>ConsensusGraph</code>. <code>ConsensusGraph::on_new_block()</code> acquires the
write lock of the inner struct at the start of the function. The rest are
query functions that only acquire read locks.</p><p>The internal structure of <code>ConsensusGraphInner</code> is fairly complicated.
Generally speaking, it maintains two kinds of information. The first kind of
information is the state of the whole TreeGraph, i.e., the current <em>pivot
chain</em>, <em>timer chain</em>, <em>difficulty</em>, etc.. The second kind of information is
the state of each block (i.e., <code>ConsensusGraphNode</code> struct for each block).
Each block corresponds to a <code>ConsensusGraphNode</code> struct for its information.
When it first enters <code>ConsensusGraphInner</code>, it will be inserted into
<code>ConsensusGraphInner::arena : Slab&lt;ConsensusGraphNode&gt;</code>. The index in the
slab will become the arena index of the block in <code>ConsensusGraphInner</code>. We use
the arena index to represent a block internally instead of <code>H256</code> because it is
much cheaper. We will refer back to the fields in <code>ConsensusGraphInner</code> and
<code>ConsensusGraphNode</code> when we talk about algorithm mechanism and their
implementations.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensusnewblockhandler">ConsensusNewBlockHandler<a href="#consensusnewblockhandler" class="hash-link" aria-label="Direct link to ConsensusNewBlockHandler" title="Direct link to ConsensusNewBlockHandler">​</a></h3><p><code>ConsensusNewBlockHandler</code>
(core/src/consensus/consensus_inner/consensus_new_block_handler.rs) contains a
set of routines for processing a new block. In theory, this code could be part
of <code>ConsensusGraphInner</code> because it mostly manipulates the inner struct.
However, these routines are all subroutine of the <code>on_new_block()</code> and the
consensus_inner/mod.rs is already very complicated. We therefore decided to put
them into a separate file.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensusexecutor">ConsensusExecutor<a href="#consensusexecutor" class="hash-link" aria-label="Direct link to ConsensusExecutor" title="Direct link to ConsensusExecutor">​</a></h3><p><code>ConsensusExecutor</code> (core/src/consensus/consensus_inner/consensus_executor.rs)
is the interface struct for the standalone transaction execution thread.
<code>ConsensusExecutor::enqueue_epoch()</code> allows other threads to send an execution
task to execute the epoch of a given pivot chain block asynchronously. Once the
computation finishes, the resulting state root will be stored into
<code>BlockDataManager</code>. Other threads can call
<code>ConsensusExecutor::wait_for_result()</code> to wait for the execution of an epoch if
desired. In the current implementation, <code>ConsensusExecutor</code> also contains the
routines for the calculation for block rewards, including
<code>get_reward_execution_info()</code> and its subroutines.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="confirmationmeter">ConfirmationMeter<a href="#confirmationmeter" class="hash-link" aria-label="Direct link to ConfirmationMeter" title="Direct link to ConfirmationMeter">​</a></h3><p><code>ConfirmationMeter</code> (core/src/consensus/consensus_inner/confirmation_meter.rs)
conservatively calculates the confirmation risk of each pivot chain block. Its
result will be useful for the storage layer to determine when it is <em>safe</em> to
discard old snapshots. It can also be used to serve RPC queries about block
confirmation if we decide to provide such RPC.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="anticonecache-and-pastsetcache">AnticoneCache and PastsetCache<a href="#anticonecache-and-pastsetcache" class="hash-link" aria-label="Direct link to AnticoneCache and PastsetCache" title="Direct link to AnticoneCache and PastsetCache">​</a></h3><p><code>AnticoneCache</code> (core/src/consensus/anticone_cache.rs) and <code>PastsetCache</code>
(core/src/consensus/pastset_cache.rs) are two structs that implement customized
caches for data structures in <code>ConsensusGraphInner</code>. In the implementation of
the inner struct, we need to calculate and store the anticone set and the past
set of each block. However, it is not possible to store all of these sets in
memory. We therefore implement cache style data structures to store sets for
recently inserted/accessed blocks. If an anticone/past set is not found in the
cache, we will recalculate the set in the current inner struct implementation. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="important-algorithmic-mechanisms">Important Algorithmic Mechanisms<a href="#important-algorithmic-mechanisms" class="hash-link" aria-label="Direct link to Important Algorithmic Mechanisms" title="Direct link to Important Algorithmic Mechanisms">​</a></h2><p>There are several important algorithmic mechanisms in the Conflux Consensus
Layer. Here we will talk about them from the implementation aspect. See XXX for
the algorithmic reasoning behind them.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pivot-chain-and-total-order">Pivot Chain and Total Order<a href="#pivot-chain-and-total-order" class="hash-link" aria-label="Direct link to Pivot Chain and Total Order" title="Direct link to Pivot Chain and Total Order">​</a></h3><p>The basic idea of the Conflux consensus algorithm is to first make everyone
agree on a pivot chain. It then expands the total order from the pivot chain to
cover all blocks with a topological sort. As long as the pivot chain does not
change/reorg, the total order of blocks will stay the same, so does the derived
order of transactions. </p><p>Comparing with Bitcoin/Ethereum, the consensus in Conflux has two key
differences: </p><ol><li><p><em>almost every block</em> will go into the total order, not just the agreed pivot
chain.</p></li><li><p>The transaction validity and the block validity are <em>independent</em>. For example, a
transaction is invalid if it was included before or it cannot carry out due to
insufficient balance. Such invalid transactions will become noop during the
execution. However, <em>unlike Bitcoin and Ethereum blocks containing such
transactions will not become invalid</em>.</p></li></ol><p>In <code>ConsensusGraphInner</code>, the arena index of the current pivot chain blocks are
stored in order in the <code>pivot_chain[]</code> vector. To maintain it, we calculate the
lowest common ancestor (LCA) between the newly inserted block and the current best
block following the GHAST rule. If the fork corresponding to the newly inserted
block for the LCA ended up to be heavier, we will update the <code>pivot_chain[]</code> from
the forked point.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="timer-chain">Timer Chain<a href="#timer-chain" class="hash-link" aria-label="Direct link to Timer Chain" title="Direct link to Timer Chain">​</a></h3><p>Blocks whose PoW quality is <code>timer_chain_difficulty_ratio</code> times higher than the target
difficulty are <em>timer blocks</em>. The <code>is_timer</code> field of the block will be set to
True. The consensus algorithm then finds the longest timer block chain (more
accurately, with greatest accumulated difficulty) similar to the Bitcoin
consensus algorithm of finding the longest chain. The arena index of this
longest timer chain will be stored into <code>timer_chain[]</code>. </p><p>The rationale of the timer chain is to provide a coarse-grained measurement of
time that cannot be influenced by a malicious attacker. Because timer blocks
are rare and generated slowly (if <code>timer_chain_difficulty_ratio</code> is properly
high), a malicious attacker cannot prevent the growth of the timer chain unless
it has the majority of the computation power. Therefore how many timer chain
blocks appear in the past set of a block is a good indication about the latest
possible generation time of the block. We compute this value for each block and
store it in <code>timer_chain_height</code> field of the block.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="weight-maintenance-with-link-cut-tree">Weight Maintenance with Link-Cut Tree<a href="#weight-maintenance-with-link-cut-tree" class="hash-link" aria-label="Direct link to Weight Maintenance with Link-Cut Tree" title="Direct link to Weight Maintenance with Link-Cut Tree">​</a></h3><p>To effectively maintain the pivot chain, we need to query the total weight of a
subtree. Conflux uses a Link-Cut Tree data structure to maintain the subtree
weights in O(log n). The Link-Cut Tree can also calculate the LCA of any two nodes
in the TreeGraph in O(log n). The <code>weight_tree</code> field in <code>ConsensusGraphInner</code>
is the link-cut tree that stores the subtree weight of every node. Note that
the implementation of the Link-Cut Tree is in the utils/link-cut-tree
directory.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="adaptive-weight">Adaptive Weight<a href="#adaptive-weight" class="hash-link" aria-label="Direct link to Adaptive Weight" title="Direct link to Adaptive Weight">​</a></h3><p>If the TreeGraph is under a liveness attack, it may fail to converge under one
block for a while. To handle this situation, the GHAST algorithm idea is to
start to generate adaptive blocks, i.e., blocks whose weights are redistributed
significantly so that there will be many zero weight blocks with a rare set of
very heavy blocks. Specifically, if the PoW quality of an adaptive block is
<code>adaptive_heavy_block_ratio</code> times of the target difficulty, the block
will have a weight of <code>adaptive_heavy_block_ratio</code>; otherwise, the block will
have a weight of zero. This effectively slows down the confirmation
temporarily but will ensure the consensus progress.</p><p>Because adaptive weight is a mechanism to defend against rare liveness attacks,
it should not be turned on during the normal scenario. A new block is adaptive
only if: 1) one of its ancestor blocks is still not the dominant subtree
comparing to its siblings, and 2) a significantly long period of time has passed
between the generation of that ancestor block and the new block (i.e., the
difference of <code>timer_chain_height</code> is sufficiently large). <code>ConsensusGraphInner::adaptive_weight()</code>
and its subroutines implement the algorithm to determine whether a block is
adaptive or not. Note that the implementation uses another link-cut-tree
<code>adaptive_tree</code> as a helper. Please see the inlined comments for the
implementation details. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="partial-invalid">Partial Invalid<a href="#partial-invalid" class="hash-link" aria-label="Direct link to Partial Invalid" title="Direct link to Partial Invalid">​</a></h3><p>Note that the past set of a new block denotes all the blocks that the generator
of the new block observes at the generation time. Therefore, from the past set
of a new block, other full nodes could determine whether it chooses the correct
parent block and whether it should be adaptive or not. </p><p>The Conflux consensus algorithm defines those blocks who choose incorrect
parents or fill in incorrect adaptive status as <em>partial invalid blocks</em>. For a
partial invalid block, the <code>partial_invalid</code> field will be set to True. The
algorithm requires the partial invalid blocks being treated differently from
the normal blocks in three ways:</p><ol><li><p>All honest nodes will not reference directly or indirectly partial invalid
blocks until a significant period of time. This time period is measured with
the <code>timer_chain_height</code> and the difference has to be more than
<code>timer_chain_beta</code>. Yes, it means that if another otherwise perfectly fine
block referencing the partial invalid block, both of these two blocks will not
be referenced for a while.</p></li><li><p>Partial invalid blocks will have no block reward. They are extremely
unlikely to get any reward anyway because of their large anticone set due to
the first rule.</p></li><li><p>Partial invalid blocks are excluded from the timer chain consideration.</p></li></ol><p>To implement the first rule, the <code>on_new_block()</code> routine in
<code>ConsensusNewBlockHandler</code> is separated into two subroutine
<code>preactivate_block()</code> and <code>activate_block()</code>. <code>preactivate_block()</code> compute and
determine whether a block is partial invalid or not, while <code>activate_block()</code>
fully integrate a block into the consensus graph inner data structures. For
every new block, the field <code>active_cnt</code> tracks how many inactive blocks it
references. A block is inactive if it references directly or indirectly a
partial invalid block. <code>activate_block()</code> will be called on a block only when
<code>active_cnt</code> of the block becomes zero. The field <code>activated</code> denotes whether a
block is active or not. For partially invalid blocks, their activation will be
delayed till the current timer chain height of the ledger is <code>timer_chain_beta</code>
higher than the invalid block. Newly generated blocks will not reference any
inactive blocks, i.e., these inactive blocks are treated as if they were not in
the TreeGraph.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="anticone-past-view-and-ledger-view">Anticone, Past View, and Ledger View<a href="#anticone-past-view-and-ledger-view" class="hash-link" aria-label="Direct link to Anticone, Past View, and Ledger View" title="Direct link to Anticone, Past View, and Ledger View">​</a></h3><p>In order to check the partial invalid status of each block, we need to operate
under the <em>past view</em> of the block to determine its correct parent and its
adaptivity. This is different from the current state of the TreeGraph or we
call it the <em>ledger view</em>, i.e., all blocks in the anticone and the future set
of the block are excluded. Because we process blocks in topological order, the
future set of a new block is empty. We therefore need to eliminate all anticone
blocks only.</p><p><code>compute_and_update_anticone()</code> in <code>ConsensusNewBlockHandler</code> computes the
anticone set of a new block. Note that because the anticone set may be very
large, we have two implementation level optimizations. First, we represent the
anticone set as a set of barrier nodes in the TreeGraph, i.e., a set of
subtrees where each block in the subtrees is in the anticone set. Second, we
will maintain the anticone set of the recently accessed/inserted blocks
only. When checking whether a block is valid in its past view or not (e.g., in
<code>adaptive_weight()</code> and in <code>check_correct_parent()</code>), we first cut all barrier
subtrees from the link-cut weight trees accordingly to get the state of the
past view. After the computation, we restore these anticone subtrees.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="check-correct-parent">Check Correct Parent<a href="#check-correct-parent" class="hash-link" aria-label="Direct link to Check Correct Parent" title="Direct link to Check Correct Parent">​</a></h3><p>To check whether a new block chooses a correct parent block or not, we first
compute the set of blocks inside the epoch of the new block assuming that
the new block is on the pivot chain. We store this set to the field
<code>blockset_in_own_view_of_epoch</code>. We then iterate over every candidate block in
this set to make sure that the chosen parent block is better than it.
Specifically, we find out the two fork blocks of the candidate block and the
parent block from their LCA and make sure that the fork of the parent is
heavier. This logic is implemented in <code>check_correct_parent()</code> in
<code>ConsensusNewBlockHandler</code>.</p><p>Note that <code>blockset_in_own_view_of_epoch</code> may become too large to hold
consistently in memory as well. Especially if a malicious attacker tries to
generate invalid blocks to blow up this set. The current implementation will
only periodically clear the set and only keep the sets for pivot chain blocks.
Note that for pivot chain blocks, this set will also be used during the
transaction execution.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fallback-brute-force-methods">Fallback Brute Force Methods<a href="#fallback-brute-force-methods" class="hash-link" aria-label="Direct link to Fallback Brute Force Methods" title="Direct link to Fallback Brute Force Methods">​</a></h3><p>There are situations where the anticone barrier set is too large if a malicious
attacker tries to launch a performance attack on Conflux. This will make the
default strategy worse than O(n) because there is a factor of O(log n) for each
block in the barrier set when we do the link-cut tree chopping. To this end, we
implemented a brute force routine <code>compute_subtree_weights()</code> to compute the
subtree weights of each block in a past view for O(n). We also implement
<code>check_correct_parent_brutal()</code> and <code>adaptive_weight_impl_brutal()</code> to use the
brute-force computed subtree weight to do the checking instead. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="force-confirmation">Force Confirmation<a href="#force-confirmation" class="hash-link" aria-label="Direct link to Force Confirmation" title="Direct link to Force Confirmation">​</a></h3><p>The Conflux consensus algorithm will <em>force confirm</em> a block if 1) there are
<code>timer_chain_beta</code> consecutive timer chain blocks under the subtree of the
block and 2) afterward there are at least <code>timer_chain_beta</code> timer chain blocks
following (not required in the subtree though). Force confirmation means that
new blocks should follow this block as their ancestor no matter what, ignoring
subtree weights. Though extremely unlikely a force confirmed block will have
lesser weights than its siblings.</p><p>The force confirmation mechanism is to enable checkpoint, which we will
describe later. It is based on the rationale that:</p><ol><li><p>Reverting a <code>timer_chain_beta</code> length timer chain is impossible.</p></li><li><p>Therefore force confirmed block will always move along the pivot chain, not
drifting between its siblings.</p></li></ol><p>We compute the accumulative LCA of the last <code>timer_chain_beta</code> timer chain
blocks and store it at the <code>timer_chain_accumulative_lca[]</code> field. This vector
is <code>timer_chain_beta</code> shorter than <code>timer_chain[]</code> because the force confirm
needs at least <code>timer_chain_beta</code> timer chain block trailing, so their LCAs do
not matter. <code>check_correct_parent()</code> and <code>adaptive_weight()</code> and their
subroutines also respect this force confirm point during their checking.
Specifically, any fork before the force confirm height is ignored.</p><p>Note that this force confirm rule is also defined based on <em>past view</em> of each
block. With the computed anticone information, <code>compute_timer_chain_tuple()</code> in
<code>ConsensusGraphInner</code> computes the timer chain related information of each
block under its past view. The results of this function include the difference of
the <code>timer_chain[]</code>, <code>timer_chain_accumulative_lca[]</code>, and <code>timer_chain_height</code>
between the ledger view and the past view. We can use the diff and the current
ledger view values to get the past view values.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="era">Era<a href="#era" class="hash-link" aria-label="Direct link to Era" title="Direct link to Era">​</a></h3><p>In order to implement the checkpoint mechanism, the Conflux consensus algorithm split the
graph into eras. Every era contains <code>era_epoch_count</code> epochs. For example, if the
<code>era_epoch_count</code> is 50000, then there is a new era every 50000 epochs. The
pivot chain block at the height 50000 will be the genesis of a new era.
At the era boundary, there are several differences from the normal case.</p><ol><li><p>A block will enter the total order for execution only if 1) it is under the
subtree of the previous era genesis and 2) it is inside the past set of the next era genesis in
the pivot chain.</p></li><li><p>Anticone penalty calculation for the block reward does not go across the era
boundary.</p></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="checkpoint">Checkpoint<a href="#checkpoint" class="hash-link" aria-label="Direct link to Checkpoint" title="Direct link to Checkpoint">​</a></h3><p>Inside <code>ConsensusGraphInner</code>, there are two key height pointers, the current
checkpoint era genesis block height (<code>cur_era_genesis_height</code>) and the current
stable era genesis block height (<code>cur_era_stable_height</code>). These two height pointers
will always point to some era genesis (being a multiple of <code>era_epoch_count</code>).
Initially, both of these two pointers will point to the true genesis (height
0).</p><p>A new era genesis block becomes stable (i.e., <code>cur_era_stable_height</code> moves) if
the block is <em>force confirmed</em> in the current TreeGraph. A stable era genesis
block becomes a new checkpoint (i.e., <code>cur_era_genesis_height</code> moves) if:</p><ol><li><p>The block is <em>force confirmed in the past view of the stable era genesis block</em>. </p></li><li><p>In the anticone of this block, there is no timer chain block.</p></li></ol><p><code>should_move_stable_height()</code> and <code>should_form_checkpoint_at()</code> in
<code>ConsensusNewBlockHandler</code> are invoked after every newly inserted block to test
the above two conditions. Generally speaking, the stable era genesis block will never be
reverted off the pivot chain. Any block in the past set of the checkpoint block
is no longer required for the future computation of the consensus layer.
Therefore, after a new checkpoint is formed, <code>make_checkpoint_at()</code> in
<code>ConsensusNewBlockHandler</code> is called to clean up those blocks that are not in
the future set of the new checkpoint.</p><p>Note that the checkpoint mechanism also changes how we handle a new block. For
a new block:</p><ol><li><p>If the new block is outside the subtree of the current checkpoint, we only
need to insert a stub into our data structure (because a block under the
subtree may be indirectly referenced via this stub block). We do not need to
care about such a block because it is not going to change the timer chain and it
is not going to be executed.</p></li><li><p>If the past set of the new block does not contain the stable era genesis block, we
do not need to check the partial invalid status of this block. This is because
this block will not change the timer chain (recall our assumption that the timer
chain will not reorg for more than <code>timer_chain_beta</code> blocks) and future blocks can reference
this block directly (since the timer chain difference is already more than <code>timer_chain_beta</code>).</p></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="deferred-execution">Deferred Execution<a href="#deferred-execution" class="hash-link" aria-label="Direct link to Deferred Execution" title="Direct link to Deferred Execution">​</a></h3><p>Because the TreeGraph pivot chain may oscillate temporarily, we defer the
transaction execution for <code>DEFERRED_STATE_EPOCH_COUNT</code> epochs (default 5).
After a pivot chain update, <code>activate_block()</code> routine will enqueue the
execution task of the new pivot chain except for the last five epochs. It calls
<code>enqueue_epoch()</code> in <code>ConsensusExecutor</code> to enqueue each task.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="block-reward-calculation">Block Reward Calculation<a href="#block-reward-calculation" class="hash-link" aria-label="Direct link to Block Reward Calculation" title="Direct link to Block Reward Calculation">​</a></h3><p>Because there is no explicit coinbase transaction in Conflux, all block rewards
are computed implicitly during the transaction execution. In Conflux, the block
reward is determined by the base reward and the penalty ratio based on the total weight of
its anticone blocks divided by its epoch pivot block&#x27;s target difficulty. This anticone set only
considers blocks appearing no later than the next <code>REWARD_EPOCH_COUNT</code> epochs.
Specifically, if there is a new era then the anticone set will not count across
the era boundary as well. <code>get_pivot_reward_index()</code> in <code>ConsensusExecutor</code>
counts this reward anticone threshold.
<code>get_reward_execution_info_from_index()</code> in <code>ConsensusExecutor</code> and its
subroutines compute this anticone set given the threshold point in the pivot
chain.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="blaming-mechanism">Blaming Mechanism<a href="#blaming-mechanism" class="hash-link" aria-label="Direct link to Blaming Mechanism" title="Direct link to Blaming Mechanism">​</a></h3><p>It is infeasible to validate the filled state root of a block because we
would need to execute all transactions in a different order in the past view of
that block. Instead, we will only ask full nodes to validate the state root
results on the current pivot chain. It then fills a blame number to indicate
how many levels ancestors from the parent who do not have correct state root.
When this number is greater than zero, the filled deferred state root becomes a
Merkel H256 vector that contains the corrected state roots of the ancestors
along with the correct one. <code>get_blame_and_deferred_state_for_generation()</code> in
<code>ConsensusGraph</code> computes the blame information for the block generation.
<code>first_trusted_header_starting_from()</code> in <code>ConsensusGraph</code> is a useful helper
function to compute the first trustworthy header based on the subtree blame
information.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="multi-thread-design">Multi-Thread Design<a href="#multi-thread-design" class="hash-link" aria-label="Direct link to Multi-Thread Design" title="Direct link to Multi-Thread Design">​</a></h2><p>The consensus layer has one thread dedicated to processing new blocks from the
synchronization layer and one thread dedicated to executing transactions. It of
course also has a set of interface APIs that RPC threads and synchronization
threads may call.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensus-worker">Consensus Worker<a href="#consensus-worker" class="hash-link" aria-label="Direct link to Consensus Worker" title="Direct link to Consensus Worker">​</a></h3><p><code>Consensus Worker</code> is a thread created by the synchronization layer. During
the normal running phase, every new block will be sent to a channel connecting
the synchronization thread and the consensus worker thread. The consensus work
thread consumes each block one by one and invokes <code>consensus::on_new_block()</code>
to process it. Note that the synchronization layer ensures the new block to be
<em>header-ready</em> when it is delivered to <code>Consensus Worker</code>, i.e., all of its
ancestor/past blocks are already delivered to the consensus layer before itself.
This enables the consensus layer to always deal with a well-defined
direct acyclic graph without holes.</p><p>One advantage of having a single thread to be dedicated to the consensus
protocol is that it simplifies the protocol implementation a lot. Because the
details of the consensus protocol are complicated and the implementation involves
many sophisticated data structure manipulations, the single thread design makes
sure that we do not need to worry about deadlocks or races. Upon the entrance
of <code>consensus::on_new_block()</code>, the thread acquires the write lock of the inner
of the consensus struct (i.e., ConsensusGraphInner). During the normal phase,
this thread should be the only one modifying the inner struct of the consensus
layer.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consensus-execution-worker">Consensus Execution Worker<a href="#consensus-execution-worker" class="hash-link" aria-label="Direct link to Consensus Execution Worker" title="Direct link to Consensus Execution Worker">​</a></h3><p><code>Consensus Execution Worker</code> is a thread created at the start of the consensus
layer. It is dedicated to transaction execution. There is a channel connecting
<code>Consensus Worker</code> with <code>Consensus Execution Worker</code>. Once the consensus
protocol determines the order of the pivot chain, it will send an <code>ExecutionTask</code>
for each epoch in the pivot chain to the channel. These tasks will be picked up
by the <code>Consensus Execution Worker</code> thread one by one. The thread loads the
previous state before the executed epoch from the storage layer as the input,
runs all transactions in the executed epoch (see
<code>ConsensusExecutor::process_epoch_transactions()</code>), and produces the result
state as the output.</p><p>The rationale of separating the transaction execution from the consensus
protocol implementation is for performance. With our <em>blaming mechanism</em>, the
execution result state is completely separated from the consensus protocol
implementation. The <em>deferred execution mechanism</em> gives us extra room to
pipeline the consensus protocol and the transaction execution. It is therefore
not wise to block the <code>Consensus Worker</code> thread to wait for the execution
results from coming back.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-assumptions-invariants-and-rules">Key Assumptions, Invariants, and Rules<a href="#key-assumptions-invariants-and-rules" class="hash-link" aria-label="Direct link to Key Assumptions, Invariants, and Rules" title="Direct link to Key Assumptions, Invariants, and Rules">​</a></h2><p>If you want to write code to interact with the Conflux consensus layer, it is
very important to understand the following assumptions and rules.</p><ol><li><p>The consensus layer assumes that the passed <code>BlockDataManager</code> is in a
consistent state. It means that the <code>BlockDataManager</code> contains the correct current
checkpoint/stable height. Blocks before the checkpoint and the stable height
are properly checked during previous execution and they are persisted into the
<code>BlockDataManager</code> properly. The consensus layer <strong>does not check</strong> the results
it fetches from the block data manager. If it is inconsistent, the consensus
layer will execute incorrectly or crash!</p></li><li><p>Besides the subroutines of <code>on_new_block()</code>, <strong>no one should hold the write
lock of the inner struct</strong>! Right now the only exception for this rule is
<code>assemble_new_block_impl()</code> because of computing the adaptive field and this is
not good we plan to change it. Acquiring the write lock of the inner struct
is very likely to cause deadlock given the complexity of the Consensus layer
and its dependency with many other components. Always try to avoid this!</p></li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Conflux-Chain/conflux-documentation/edit/main/docs/general/build/node-development/consensus-design.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/node-development"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Node Development</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/general/build/node-development/rigorous-testing"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Rigorous Testing Tools for Conflux</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#design-goals" class="table-of-contents__link toc-highlight">Design Goals</a></li><li><a href="#structures-and-components" class="table-of-contents__link toc-highlight">Structures and Components</a><ul><li><a href="#consensusgraph" class="table-of-contents__link toc-highlight">ConsensusGraph</a></li><li><a href="#consensusgraphinner" class="table-of-contents__link toc-highlight">ConsensusGraphInner</a></li><li><a href="#consensusnewblockhandler" class="table-of-contents__link toc-highlight">ConsensusNewBlockHandler</a></li><li><a href="#consensusexecutor" class="table-of-contents__link toc-highlight">ConsensusExecutor</a></li><li><a href="#confirmationmeter" class="table-of-contents__link toc-highlight">ConfirmationMeter</a></li><li><a href="#anticonecache-and-pastsetcache" class="table-of-contents__link toc-highlight">AnticoneCache and PastsetCache</a></li></ul></li><li><a href="#important-algorithmic-mechanisms" class="table-of-contents__link toc-highlight">Important Algorithmic Mechanisms</a><ul><li><a href="#pivot-chain-and-total-order" class="table-of-contents__link toc-highlight">Pivot Chain and Total Order</a></li><li><a href="#timer-chain" class="table-of-contents__link toc-highlight">Timer Chain</a></li><li><a href="#weight-maintenance-with-link-cut-tree" class="table-of-contents__link toc-highlight">Weight Maintenance with Link-Cut Tree</a></li><li><a href="#adaptive-weight" class="table-of-contents__link toc-highlight">Adaptive Weight</a></li><li><a href="#partial-invalid" class="table-of-contents__link toc-highlight">Partial Invalid</a></li><li><a href="#anticone-past-view-and-ledger-view" class="table-of-contents__link toc-highlight">Anticone, Past View, and Ledger View</a></li><li><a href="#check-correct-parent" class="table-of-contents__link toc-highlight">Check Correct Parent</a></li><li><a href="#fallback-brute-force-methods" class="table-of-contents__link toc-highlight">Fallback Brute Force Methods</a></li><li><a href="#force-confirmation" class="table-of-contents__link toc-highlight">Force Confirmation</a></li><li><a href="#era" class="table-of-contents__link toc-highlight">Era</a></li><li><a href="#checkpoint" class="table-of-contents__link toc-highlight">Checkpoint</a></li><li><a href="#deferred-execution" class="table-of-contents__link toc-highlight">Deferred Execution</a></li><li><a href="#block-reward-calculation" class="table-of-contents__link toc-highlight">Block Reward Calculation</a></li><li><a href="#blaming-mechanism" class="table-of-contents__link toc-highlight">Blaming Mechanism</a></li></ul></li><li><a href="#multi-thread-design" class="table-of-contents__link toc-highlight">Multi-Thread Design</a><ul><li><a href="#consensus-worker" class="table-of-contents__link toc-highlight">Consensus Worker</a></li><li><a href="#consensus-execution-worker" class="table-of-contents__link toc-highlight">Consensus Execution Worker</a></li></ul></li><li><a href="#key-assumptions-invariants-and-rules" class="table-of-contents__link toc-highlight">Key Assumptions, Invariants, and Rules</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://confluxnetwork.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">Conflux Website</a></li><li class="footer__item"><a href="https://forum.conflux.fun" target="_blank" rel="noopener noreferrer" class="footer__link-item">Conflux Forum</a></li><li class="footer__item"><a href="https://github.com/Conflux-Chain" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discord.gg/3BhYcCM4HY" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://t.me/Conflux_English" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram</a></li><li class="footer__item"><a href="https://app.dework.xyz/conflux" target="_blank" rel="noopener noreferrer" class="footer__link-item">DeWork</a></li></ul></div><div class="col footer__col"><div class="footer__title">Developers</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://twitter.com/ConfluxDevs" target="_blank" rel="noopener noreferrer" class="footer__link-item">ConfluxDevs Twitter</a></li><li class="footer__item"><a href="https://t.me/ConfluxDevs" target="_blank" rel="noopener noreferrer" class="footer__link-item">ConfluxDevs Telegram</a></li><li class="footer__item"><a href="https://forum.conflux.fun/t/open-technical-grants/14399" target="_blank" rel="noopener noreferrer" class="footer__link-item">Open Technical Grants<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/Conflux-Chain/conflux-documentation" target="_blank" rel="noopener noreferrer" class="footer__link-item">Contribute (Github)<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="/img/footer_logo.svg" alt="Conflux Copyright Logo" class="themedImage_ToTc themedImage--light_HNdA footer__logo" width="32" height="16"><img src="/img/footer_logo.svg" alt="Conflux Copyright Logo" class="themedImage_ToTc themedImage--dark_i4oU footer__logo" width="32" height="16"></div><div class="footer__copyright">Copyright © 2023 ConfluxNetwork, Inc.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.55012e2d.js"></script>
<script src="/assets/js/main.c401082f.js"></script>
</body>
</html>