"use strict";(self.webpackChunkconflux_docs=self.webpackChunkconflux_docs||[]).push([[6139],{67675:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>t,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var o=a(85893),n=a(11151);const l={sidebar_position:3,title:"GHAST",displayed_sidebar:"generalSidebar"},r=void 0,i={id:"general/conflux-basics/consensus-mechanisms/proof-of-work/ghast",title:"GHAST",description:"GHAST (Greedy-Heaviest-Adaptive-SubTree)",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/general/conflux-basics/consensus-mechanisms/proof-of-work/ghast.md",sourceDirName:"general/conflux-basics/consensus-mechanisms/proof-of-work",slug:"/general/conflux-basics/consensus-mechanisms/proof-of-work/ghast",permalink:"/es/docs/general/conflux-basics/consensus-mechanisms/proof-of-work/ghast",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/conflux/es",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"GHAST",displayed_sidebar:"generalSidebar"},sidebar:"generalSidebar",previous:{title:"La estructura Tree-Graph",permalink:"/es/docs/general/conflux-basics/consensus-mechanisms/proof-of-work/tree-graph"},next:{title:"Introducci\xf3n a PoS",permalink:"/es/docs/general/conflux-basics/consensus-mechanisms/proof-of-stake/pos_overview"}},t={},c=[];function d(e){const s={p:"p",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.p,{children:"GHAST (Greedy-Heaviest-Adaptive-SubTree)"}),"\n",(0,o.jsx)(s.p,{children:'Conflux Research Group ha desarrollado el mecanismo GHAST para abordar la cuesti\xf3n del "liveness attack". El mecanismo consiste en aplicar la regla de cadena m\xe1s pesada pero con un sistema de pesos de bloque modificado. El tipo de bloque se decide en base a la estructura tree-graph hist\xf3rica del bloque, no a la discreci\xf3n del minero. Con el mecanismo GHAST, la regla de la cadena m\xe1s pesada se aplica seleccionando el bloque hijo con el peso m\xe1s alto del \xe1rbol hijo del \xfaltimo bloque de la cadena principal. El c\xe1lculo del peso del bloque para el sub\xe1rbol ya no se basa \xfanicamente en el recuento de bloques sino tambi\xe9n en la suma de los pesos. El mecanismo GHAST, permitiendo a los mineros generar bloques especiales, aumenta la dificultad del bloque y ralentiza la velocidad de producci\xf3n del bloque, lo que ayuda a resolver el problema del "liveness attack".'}),"\n",(0,o.jsx)(s.p,{children:"Las partes centrales del mecanismo GHAST pueden resumirse de la siguiente manera:"}),"\n",(0,o.jsx)(s.p,{children:"Se aplica la regla de cadena m\xe1s pesada, pero el bloque tiene tres pesos diferentes: 0, 1, X. Cuando X es un n\xfamero relativamente grande, por ejemplo X = 1000 (ignorando la situaci\xf3n que implica el ajuste de dificultad minera)."}),"\n",(0,o.jsx)(s.p,{children:"Hay dos tipos de bloques en la red: bloques normales y bloques especiales. El peso del bloque normal es siempre 1; el peso del bloque especial se determina de acuerdo a la dificultad del bloque \u2014 hay pesas de bloque especial 1/X de X, mientras que el resto son 0. Minar un bloque normal tiene la misma dificultad que un bloque especial."}),"\n",(0,o.jsx)(s.p,{children:"El tipo de bloque est\xe1 determinado por la estructura hist\xf3rica del tree-graph Puesto que el generador de un bloque no puede especificar arbitrariamente el tipo de bloque."}),"\n",(0,o.jsx)(s.p,{children:"En ausencia de un ataque, todos los bloques honestos reci\xe9n generados deber\xedan convertirse en bloques normales; despu\xe9s de que el atacante lleve a cabo cualquier tipo de \u201cliveness attack\u201d y contin\xfae durante un tiempo suficiente, todos los bloques honestos reci\xe9n generados se convierten en bloques especiales."})]})}function u(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},11151:(e,s,a)=>{a.d(s,{Z:()=>i,a:()=>r});var o=a(67294);const n={},l=o.createContext(n);function r(e){const s=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(l.Provider,{value:s},e.children)}}}]);